------------------------------------------------------
8/5/22 To do today

✅    Make some music with the chords you made for Balloon Drum Music. Build a woodwind orchestra.

✅    Start logging to a log file instead of print().                  

----------------------------------------------
8/6/22 To do today:

✅    Double check the note numbers between the chart and the notebook. The diamond to the 31 limit online is bogus. Lots of wrong numbers for the note number. But the ratios, names, and locations are correct. I couldn't get Sagittal installed, and the replacement is not compatible with Sagittal. I installed BravuraMSS, and I can see some of the characters, but they don't match what Sagittal provided. Dave Keenan came to my rescue and I have the Sagittal font now. Some of the notes aren't right, but enough are to just move on. 40 - 127 are good. 160 - 242 seem good too. But 128 through 159 are whack. I think I fixed them. Now I need to fix the diamond in the spreadsheet, save it as a jpeg, and post it to the notebook.

✅    I have it as a jpeg now. Need to overwrite this: http://ripnread.com/listen/31-Limit-Just-Tonality-Diamond.jpg
Actually, I left that one up there, but made a new one here: http://ripnread.com/listen/Diamond_31-limit.jpg
Almost legible in a half screen.

----------------------------------------------
8/7/22 To do today:

✅    Figure out why the logging starts going to ball.log, then switches to open_samples3.log weird. 
      The important thing is to make sure it doesn't restart logging in any of the following calls:
            stretch.piano_roll_to_pfields(csound_params) 
            p.load_csd
            stretch.process_pfields_to_csd_file
            
✅    Convert the vstack to np.concatenate 

-----------------------
8/8/22 to do today:

Include finger piano and balloon drums along with the woodwinds. 
      Fewer winds. Loose the eng horn, bach trumpet, contra bassoon. That was much harder than I remember. At first I couldn't get the tempo to work. I had to have multiple voices before it started working with the q variable. Prior to that it was ignoring the q4000. No idea why.

--------------------
8/9/22 to do today:

✅    Fix the tempo assignment. It's whack. 
      t 0 117 100.0 117 100.0 104 100.0 104 100.0 104 100.0 104 100.0 103 100.0 103 100.0 99 100.0 99 100.0 99 100.0 99 100.0  
      Spent two hours on it and I can't figure it out. Amazing.   
      t 0 138 108.0 138 108.0 147 216.0 147 216.0 147; must leave off the last one or add one more tempo at the end
      Fixed it. Tempo is way too fast at the moment. But it works. The key is adding one more at the end of the string.
      
----------------------------------------
8/10/22 To do today:

✅    You have the outline of a piece of music now. 
      Circle through the ABCD modes and back to A. Fix up the ending of each section, perhaps eliminate gaps. Think about transitions. 

------------------------------
8/12/22 To do today:

☐     put all the chord assignments into a python module and import it. 
      Clutters up the notebook.  Bbmaj_A_1 and the like ABCD, all chords

☐     There are many levers in the variable setting cell of the notebook. 
      What are the most important levers affecting the musical quality?

✅    I think I'm going to have to double up the voices, and use pfields to csound to limit the voices at any one time. 
      It's already 32 voices. Take a look at the zero to one ratios. I reduced the zeros and increased the ones.
      Looking at coconet_open_samples.ipynb for some ideas on how to do that. 
      It was a mess. for row in pfields:
      The idea should be that we have a list of lists of voices, and if the voice of the row is in the list, then it gets played, otherwise it is dropped. 
            collection = [[1, 2], [5, 6, 7, 13], [9, 10, 11, 12, 13], [1, 7, 10, 12], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]      
      
✅    The key is knowing when to switch from one list of lists to the next.  Some key ideas that I took advantage of:
            - Current time_step: pfields[17] 
            - Adjust volume and velocity for downbeats: volume(pfields[i][3] and the velocity pfields[i][14] is the volume)
            - voice is row[6]. If in collection[this_collection] - collection is a list of lists, this_collection starts of as 0, and is incremented with each section 
            - at the end of the section, 
                  this_collection += 1
                  this_collection %= len(collection)
            - I had to add in the missing notes after the loop, which indicates I wrote the loop wrong. Is there a while loop instead of iterating through the rows of pfields. 
      I seem to have royally screwed up this section of code. I was thinking that the index of the array, i was the time_step. Not even close. It's the index through the pfields, which I don't think I even need to keep track of. So I got rid of i, now it still moves almost every pfield row into new_pfields. Crazy. Well, all but 71 of them anyway. Why? And if I change the collections array, it only moves the voice 1 into new_pfields. I think that's because pfields at this point is sorted by voice, not by time_step. pfields.sort()  fixed it.

✅    Shorter section endings. I kind of like them now. Vary the length of the section endings more. Some very long, some very short

☐     I found a reference to Erv Wilson and Cassandra on Facebook in the Xenharmonic Alliance from 3/29/2017. 
      I posted something about this on Facebook and Paul Ehrlich responded. Someone else said to look in tres.pdf in the Wilson Archives.

☐     I should do something about this bug. It's annoying. 
      shaded_mask building. total_size = 864, (zero_ratio + one_ratio) * (total_size / total_ratio) = 864.0
      shaded_mask building. total_size = 512, (zero_ratio + one_ratio) * (total_size / total_ratio) = 512.0
      INFO:root:mask_zeros = 8, mask_ones = 3
      shaded_mask building. total_size = 800, (zero_ratio + one_ratio) * (total_size / total_ratio) = 800.0000000000001
      The sum of the ratios 11 must be divisible into the product of the mask shapes: 800
      72.72727272727273 is not an integer
      I'm going to have to switch from a range to specific collections of zero_ratio, one_ratio, total_size, total_ratio. 

✅    I need to be able to control the envelopes more closely. 
      Today, I can specify only a set of envelopes that are used across all instruments and throughout the whole piece. I can influence how likely they are. This worked when all the instruments were fairly similar, strings and plucked tines, for example. Or for bowed, plucked and vibrato strings. But when I have woodwinds, finger pianos, balloon drums and brass, I'll need some other way to control them. 
      I could change them during the scan of the pfields. 
            for row in pfields: # might be a good section to modify the envelopes. 
      This is a big job. Not really. Just a few lines
      Why is the first section sometimes empty of notes? I think I fixed it. It was because of the use of one index for both the collections: time step range and instrument collection.
            this_last_time_step += 1
            this_last_time_step %= len(last_time_step) 
            this_collection += 1
            this_collection %= len(collection_of_voices)
      This appears to have fixed it.
-------------------------------------------      
8/14/22 To do today:     

✅    Make some of the bridge sections shorter than others. End them earlier in the sequence. 

✅    Find a way to have a rather longer vamp on different tetrads. 

✅          Tetrad otonal ratios
            A     1:1 5:4 3:2 7:4
            B     9:8 11:8 13:8 15:8
            C     17:16 24:16 25:16 29:16
            D     19:16 23:16 27:16 31:16

            Tetrad utonal ratios
            A     8:7 4:3 8:5 1:1
            B     6:15 16:13 16:11 16:9
            C     32:29 32:25 32:21 32:17
            D     32:31 32:27 32:23 32:19



✅    Finished several pretty good versions. All around 10 minutes. 
      Posted #17 to ripnread.
      -rw-r--r--. 1 prent prent 25M Aug 14 15:35 /home/prent/Dropbox/Uploads/ball2-t17.mp3
      -rw-r--r--. 1 prent prent 20M Aug 14 15:21 /home/prent/Dropbox/Uploads/ball2-t11.mp3
      -rw-r--r--. 1 prent prent 27M Aug 14 15:16 /home/prent/Dropbox/Uploads/ball2-t12.mp3
      -rw-r--r--. 1 prent prent 29M Aug 14 13:51 /home/prent/Dropbox/Uploads/ball2-t13.mp3
      -rw-r--r--. 1 prent prent 26M Aug 14 13:47 /home/prent/Dropbox/Uploads/ball2-t14.mp3
      -rw-r--r--. 1 prent prent 28M Aug 14 13:44 /home/prent/Dropbox/Uploads/ball2-t15.mp3
      -rw-r--r--. 1 prent prent 24M Aug 14 13:37 /home/prent/Dropbox/Uploads/ball2-t16.mp3

-----------------------
8/16/22 To do today:

✅    Why does the log show up in the jupyter notebook output? 
      That's new and very annoying. Am I calling it more than once? Once I rebooted it no longer wrote the logs to the notebook. Fixed it with a reboot. It must have had something to do with running the code too many times, or out of order.

☐     What if I were to arpeggiate two separate ranges of the chorale with two different rates of speed. 
      For example, take a chord progression, tile one by 8 and another by 9, the arpeggiate each by different masks, then bring them back together.
      Do that later.

-----------------------
8/17/22 To do today:

✅    To reference a dictionary, make sure you don't get messed up with print quote marks vs. dictionary quote marks. They must be different from each other.

✅    I made the ctcsound instance produce a wave file from pfields. Next step is the live part.

----------------------
8/18/22 To do today:

✅    I can get by with 16 voices instead of 32 for the finger piano and balloon drums. Maybe even fewer, or higher zeros in the mask to thin it out.

✅    Next steps: Create a short chorale structure and use the ctcsound implementation to speed up the feedback loop. 
      Create an instance of csound that I can throw notes against live. 

✅    Make a csd file that can be used for live performance. 
      Needs a long f0 function, and route audio to live. ball3.csd is the one. I know how to set f0 to a long time, but what is the <CsOptions> statement to go live instead of to a file. Here is what sending it to a file looks like:
            -o /home/prent/Music/sflib/ball2.wav -W -G -m2 -3 
      -o means output         
      -o dac for realtime output. That's all it takes I guess. But timing is important, since the orchestra plays notes at a specified time. 
      More here: https://csound.com/docs/manual/UsingRealTime.html

      Segmentation fault. I hate segmentation faults.
----------------------------
8/22/22 To do today:

✅    See if you can call ctcsound twice without segmentation faults. 
      Switch to the flute used in Whisper Song in 53 EDO. The liner notes says bass flute, but I think it's actually alto flute.
      It looks like I made it in May 22, 2005. I found the source code, and it's definitely a bass flute 96 in the McGill.dat.
      If I'm going to make that change, also delete the unused balloon flute in ball2.csd
      
✅    There is an option to have ctcsound take the sound as it arrives, or some sort of offset factor.
            pt.scoreEvent(0, 'i', field)
      The event has type opcod (e.g. ‘i’ for a note event). 
      pFields is tuple, a list, or an ndarray of MYFLTs with all the pfields for this event, 
      starting with the p1 value specified in pFields[0]. 

      if absp2mode is 0 (False), the start time of the event is relative to the current time.
      if absp2mode is 1 (True), the start time of the event is measured from the beginning of the performance.
      I've always used False, 0 for this value. That may explain why I sometimes had the tempo go all crazy sometimes. If it was long, it would start setting the time relative to the current time, which was moving forward as more notes were sent to ctcsound. I should have said True. I'll have to confirm that later. When I switch it to 1 in the notebook, it runs the first few notes together, like it's trying to catch up. I'm going to stick with zero.

✅    Create a mask for each scale to indicate if a note has to be lowered an octave. 
      Tried that. Devilishly challenging. np.subtract works, but it's critical that all the dimensions are the same. 
      It's as hard as the np.concatenate function. If the dimensions don't match with concat, it fails. If they don't match with np.subtract, you suddenly have exploding dimensions. 

--------------------------------
8/24/22 To do today:

✅    I discovered that I can keep the ctcsound running for hours without having to shut it down. 
      I can even keep sending new chords to it.

-----------------------------
8/25/22 To do today

✅    Next step is to find a way to collect all the glissando, trills, mordants in a data structure that is indexed.
      I'm thinking I could index it by the 16 scale degrees much like to dictionary keys:
            keys = {'Bbmaj': np.array([179, 200, 0, 16, 34, 49, 63, 77, 90, 103, 115, 127, 138, 147, 159, 169]), 
                  'Dpmaj': np.array([42, 61, 79, 95, 112, 127, 141, 155, 168, 180, 194, 210, 0, 6, 21, 33]), ...
                  
            Each of those 16 scale degrees could have a different ratio to the next note. But those ratios are probably not used very often. Better to work out ratios between ranks, or within scales
            scales = {'A_oton':np.array([note % 16 for note in np.arange(0, 16, 2)]),
                  'B_oton':np.array([note % 16 for note in np.arange(2, 18, 2)]),...

            for rank in scales:
                  print(f'{rank}: {scales[rank]}')

            A_oton: [ 0  2  4  6  8 10 12 14]
            B_oton: [ 2  4  6  8 10 12 14  0]...
            
            otonal_ratios = {(0,2): 9/8, (0,4): 5/4, # I'll need the inverse of these as well. Got them.
                  (1,3): 19/17, (1,5): 21/17,
                  (2,4): 10/9, (2,6): 11/9,...
            
            Can I effectively access these ratios from my code? otonal_ratios[(0,2)] = 1.125
            Can I then call something that will return the function number in the csound file?
                  trills_2_step = {16/15: 176, 15/14: 177...
                  print(f'{trills_2_step[otonal_ratios[(14,0)]] = }')
                        trills_2_step[otonal_ratios[(14,0)]] = 176

            o_numerator = np.arange(16,32,1)
            u_denominator = np.arange(16,32,1)

            There is a marvelous function called str(Fraction(some_decimal_number).limit_denominator())
                  from fractions import Fraction
            It takes in a decimal number and writes it out as a ratio.

            print(f'list of fractions in o_numerator over 16: {[str(Fraction(num/16).limit_denominator()) for num in o_numerator]}')
            print(f'list of fractions in 16 over u_denominator: {[str(Fraction(32/num).limit_denominator()) for num in u_denominator]}')

                  unique ratios in the dictionary otonal_ratios: ['16/15', '31/29', '15/14', '29/27', '14/13', '27/25', '13/12', '25/23', '12/11', '23/21', '34/31', '11/10', '21/19', '10/9', '19/17', '9/8', '8/7', '31/27', '15/13', '7/6', '34/29', '27/23', '13/11', '25/21', '25/21', '6/5', '6/5', '23/19', '11/9', '38/31', '21/17', '5/4']

                  list of fractions in o_numerator over 16: ['1', '17/16', '9/8', '19/16', '5/4', '21/16', '11/8', '23/16', '3/2', '25/16', '13/8', '27/16', '7/4', '29/16', '15/8', '31/16']
                  list of fractions in 16 over u_denominator: ['2', '32/17', '16/9', '32/19', '8/5', '32/21', '16/11', '32/23', '4/3', '32/25', '16/13', '32/27', '8/7', '32/29', '16/15', '32/31']

            I am limited to the existing ratios in the .csd file, unless I add new ones. That restricts my use to ranks A and B.
            For example, (1,3) is 19/17 and that's not in the csound .csd file. If I could find room, I can add them. 
            I will need 30 for each of the 2 step, 8 step trills, and the slide. That's 120 new function tables. I'm already up to 536, and they have to stop before 601, that's where the samples starts the sample f tables. I don't want to dump the slide with vibrato, because that makes a mean slide guitar impression with piano samples. Kyle Gann referred to it as my whammy bar. I would have to modify the samples code, and I'm loathe to do that. 
             
            I'm also missing 6/5 ratio in the 8 step trill. Could I squeeze it in? It's only missing there. Fixed it.

-----------------------------
8/26/22 To do today

✅    Fix a few remaining missing ratios in yesterday's work. I don't have the utonal ratios, including 16/9, (I have 8/9). 
      I need to systematically look at the needed ones, 16/9 is way to big to use, as is 16/13, 4/3, 16/11, 8/5, 
      What I need are the utonal adjacent ratios - actually I don't need these. 
            
      Just A & B ranks  
            0        2     4     6      8     10      12     14     0
            2/1    16/9   8/5  16/11   4/3   16/13   8/7   16/15   1/1
                9/8    10/9  11/10  12/11 13/12  14/13  15/14  16/15
                8/9    0/10  10/11  11/12 12/13  13/14  14/15  15/16
      I have all those ratios already in the list of ratios, but the steps are only valid for the otonal scales. I need a similar table for the utonal scales. It turns out the ratios are the same as the otonal ones, becuase I'm going down instead of up, they match 100% with the otonal ratios. I wonder if I thought about that in advance.
      
✅    Saved the percussion concat_chorale to a file:
            np.save('balloon_drum_percussion', concat_chorale)
      Now I can retrieve it whenever I need it.            
            concat_chorale = np.load('balloon_drum_percussion.npy')

-----------------------------------
8/29/22 To do today:

✅    I need a section where the chords in the woodwinds held against the fast drums and finger pianos. 
      Maybe I can do that along with the melodies, scales, arpeggios, trills, slides.
      This is what I want to get done today. Make a choice about how you are going to use the glissandos and trills.
      Ideas for how to implement glissandi and trills:
            loop over pfields. update_row could transform two notes into one
            Do it earlier, and create a new place to store the fact that you want to apply a gliss to a voice/time_step 
                  You could change from a (voice, time_step) to a (voice, time_step, gliss) structure
            combine a bit of both. I completed a hybrid form: I created a chord structure as array 4, 2 four flutes 2 time_steps, then after the pfields were complete, I queried each note and replaced the gliss field (9) where the note field (4) was equal to the value that I wanted to change. That's not scalable, since not every note number 179 will have the same gliss value. But for now it works. I also made sure the gliss up used upsample 1 and gliss down used upsample 255. That made them have the same vibrato rate. I found the right glissando values for 4 different ratios: 9/10, 11/12, 13/14, 15/16 and their inversions: 10/9, 12/11, 14/13, 16/15. I testing slides, trills of 2 steps ending up, and trills of 8 steps starting on the note and ending down, or if they go up they end up.
                  for i in range(8): # check every note in the whole file - not scalable.
                        if pfields[i][4] == 34: pfields[i][9] = 35 # slide down 9/10 35 or trill down 2 steps 197 - 8 steps (528) 227 

✅    Make a separate set of chorale structures for the woodwinds than the percussion instruments. 
      Let them be the rhythm section, and create a horn section and melody in the winds. Make sure it exactly matches the timing of the percussion.
      I've built a set of scales in each of the ranks, A, B, C, D. They are all going up as default, and the utonal starts with the minor key. I can let them jump around: rng.choice(flute, size = 8, replace = False, shuffle = True)

✅    One thing that worked well in a previous piece of mine was used in 01 - Whisper Song in 53 EDO 1.mp3
      53-TET bass flute, cello martele, finger piano, and dry spring. 
      Some other things that really worked well: Flute with vibrato backed with cello martele. 
      Starting with a vamp, flute trills, then stopping everything but two slow chords on finger piano, then the slightest of breaks for 1/2 a beat. Then the flute comes in on the upbeat. Flute arpeggios across 2 octaves backed by the finger piano and cello.

☐     How come I never use dry spring any more?

✅    How can I store these slides along with the voices and time_steps.
      Prep work for a separate set of structures for winds
      The winds don't fit into the structures used for the percussion parts. Those can use the typical array of (voices, time_steps), but for the winds I need different envelopes, different durations, and especially the ability to support trills and slides. I'm thinking that I need to add additional dimensions:

            voices (instrument)
            time_step (midi equivalent number)
            envelope (short, long, etc.)
            glissando (slide, trill, none)).

✅    I noticed that I have a key that includes the mode in the name
      the mode includes the rank and the mode
      the inversion includes the mode, the rank, and the inversion
      I need to normalize these so that they only include the necessary information.
            key = 'Bbmaj' # it should only include the key
            mode = 'A_oton' # it should only include the oton or uton, not the rank 
            inversion = 'A_oton_2' # it should only include the inversion 
      Change them so that they look like this, in this order:
            key = 'Bb'
            mode = 'oton'
            rank = 'A' 
            inversion = '2'

✅    What are all the important variables needed for the dictionaries:
            rank = 'A'              # 'B', 'C', 'D'
            mode = 'oton'           # 'uton'
            key = 'Bb'              # keys.keys() = dict_keys(['Bb', 'Dp', 'Db', 'C_', 'G_', 'F_', 'Eb', 'Em'])
            gliss_type = 'slide'    # gliss.keys() = dict_keys(['trills_2_step', 'trills_8_step', 'slide'])
      Dictionaries:
            keys[mode][ratio] = array([179, 200,   0,  16,  34,  49,  63,  77,  90, 103, 115, 127, 138, 147, 159, 169])
            scales[rank][mode] = array([ 0,  2,  4,  6,  8, 10, 12, 14])
            scale_mask[rank][mode][key] = array([1, 1, 1, 1, 1, 0, 0, 0])
            inversions[rank][mode][inv] = array([ 0,  4,  8, 12])
            ratio_table[(step_start, step_stop)]) = '11/9'
            gliss[gliss_type][ratio] = 176 
      How to use:
            print(f'{str(Fraction(ratio_table[(step_start, step_stop)]).limit_denominator()) = }')
                       
      Functions:
            def build_chords(key, mode, rank, inversion): return chord
            def build_scales(key, mode, rank): return scale

✅    To use a list comprehension to print multiple values put the initial variables in parenthesis. As in:
                  
            for gliss_type in gliss.keys():
                  print(f'{gliss_type = }')
                            +-- parenthesis
                            |+-- first value
                            ||                                         +-- second value
                            ||                                         |
                  print(f'{[(str(Fraction(ratio).limit_denominator()), g_value) for ratio, g_value in gliss[gliss_type].items()]}')
✅    To see if a key is in a dictionary:
            if 'oton' in keys["Bb"]: print(f'{keys["Bb"]["oton"] = }')
                  keys["Bb"]["oton"] = array([179, 200,   0,  16,  34,  49,  63,  77,  90, 103, 115, 127, 138, 147, 159, 169])

----------------------
8/30/22 To do today:

✅    Latest problem is synching up the slides with the notes to which they belong. 
      I never know what note will appear in any of the pfields, even when I sort them. I need a way to make certain the slides stay with the note to which I want to apply them.
      The only way I can think of to link them is to modigfy piano_roll_to_pfields to do the following:
            1. Increase the dimension of the array to include many more variables than just the note number
                  this will break other uses
            2. Replace the piano_roll_to_pfields with a call containing everything needed to call ctcsound, process one time step at a time.
            Currently, inside the function it processes one voice at a time. 
                  for voice in csound_params["piece"]: # once for each voice    
      
☐     This is a time series, and perhaps I can use some time series frameworks to extend the sequences. 
      I remember a podcast on Data Skeptic with Julien Herzen
      PhD graduate from EPFL in Switzerland, spoke about his work with Unit 8 and the development of the Python Library: Darts. Follow Julien on twitter: @jlhrzn      
      Darts code: https://github.com/unit8co/darts
      Paper: '/home/prent/Dropbox/Tutorials/Classical-Piano-Composer/Darts: Machine Learning Time Series 21-1177.pdf'

✅    Make the time_step the key value in an array, then each will have at least one or more notes. 
      Notes have the characteristics that I want to send to csound. Each row has a time_step which is some relative time for an action. There could be multiple notes on each time_step. 
      What could it look like:
            time_step_headings = ['instrument', 'start', 'duration', 'velocity', 'tone', 'octave', 
                  'voice', 'stereo', 'l_envelope', 'gliss1', 'upsample', 'r_envelope', 'gliss2', 'gliss3', 'volume']
            So we have two dimensions: time_step, note_information
            This is basically the structure of input to csound, and the way I made pfields. 
            How can I get my notes, glisses, etc into this array? 
            I can create a chord of notes in the shape (4,) for 4 notes with no other dimension
            I can also create a set of glissandi that can take each note up to the next chord in shape (4,)
            How can I load those into the time_step array? 
            I can hand type the data into each row and column, but I'd rather find a better way. Tomorrow.
      I need something better than this:
            time_steps = np.array([[1, 0, 5, 60, 34, 4, 6, 8, 1, 35, 255, 0, 0, 0, 30],
                        [1, 0, 5, 60, 90, 4, 6, 8, 1, 33, 255, 0, 0, 0, 30],
                        [1, 0, 5, 60, 138, 4, 6, 8, 1, 31, 255, 0, 0, 0, 30],
                        [1, 0, 5, 60, 179, 4, 6, 8, 1, 29, 255, 0, 0, 0, 30],
                        [1, 5, 5, 60, 0, 4, 6, 8, 1, 20, 1, 0, 0, 0, 30],
                        [1, 5, 5, 60, 63, 4, 6, 8, 1, 18, 1, 0, 0, 0, 30],
                        [1, 5, 5, 60, 115, 4, 6, 8, 1, 16, 1, 0, 0, 0, 30],
                        [1, 5, 5, 60, 159, 4, 6, 8, 1, 14, 1, 0, 0, 0, 30]
                     ])
            I used samples to do this quite simply:
                  d0h50&Bbmaj.u255&n1.g35 &n5.g33 &n9.g31 &n13.g29d50
                  d0h50&Bbmaj.u1&n3.g20 &n5.g18 &n9.g16 &n13.g14d50
                  @ Bbmaj would set the &n_. variables to the right tone value
            So perhaps I should create several column values, then concatenate them all together.

✅    Transpose operator: array.T turns rows into columns and visa versa.
      
      This resulted in the correct data:
            time_step_dict = {'instrument': np.ones((8,), dtype = int),
                  'duration': duration,
                  'hold': np.ones((8,), dtype = int) * hold,
                  'velocity': np.ones((8,), dtype = int) * velocity,
                  'tone': np.concatenate((chord, chord2)),
                  'octave': np.ones((8,), dtype = int) * 4,
                  'voice': np.ones((8,), dtype = int) * 6,
                  'stereo': np.ones((8,), dtype = int) * 8, 
                  'l_envelope': np.ones((8,), dtype = int) * 1, 
                  'gliss1': slides, 
                  'upsample': np.concatenate((np.ones((4,), dtype = int) * upsamples[0], np.ones((4,), dtype = int) * upsamples[1])),
                  'r_envelope': np.ones((8,), dtype = int) * 1, 
                  'gliss2' : np.zeros((8,), dtype = int),
                  'gliss3': np.zeros((8,), dtype = int),
                  'volume': np.ones((8,), dtype = int) * volume}
            
            def array_from_dict(time_step_dict):
                  time_step_array = np.empty((len(time_step_dict),len(time_step_dict["instrument"])), dtype = int)
                  assert all([len(time_step_dict[time_step]) == len(time_step_dict["instrument"]) for time_step in time_step_dict.keys()]),\
                        "not all items are same quantity"
                  inx = 0
                  for column in time_step_dict:
                        time_step_array[inx] = time_step_dict[column]
                        inx += 1
                  return (time_step_array.T)
            
✅    So every phrase I want to create should be in the form of that dictionary. 
      It is a self contained multi note section. You can concatenate more of these together:
            # first convert the dictionary, which should have the correct format, into a numpy array, transposed.
            # the function checks that there are the right number of items in each of the dictionary keys().
            time_step_array = np.concatenate((array_from_dict(time_step_dict), array_from_dict(time_step_dict2)), axis = 1)
      So I'm trying to think of ways to speed this up. Instead of having to keep track of start times, use the idea that start time is always the sum of the preceding duration values, and each note has a separate hold value that used as the duration in each note. 
      Stop using start, duration
      start using duration, hold, and save somewhere the current start value as the sum of the durations that preceded it.
      It's more complicated than you remember. 
      If I'm not careful, the start time column starts to get very big. You can't go through the rows more than once, because it modifies the start location from what it was, to what it needs to be for the ctcsound invocation.
      Solved that by copy.deepcopy so I'm always using a new copy of the array and can run as many times as I want.
      Making progress.
      I need a separate data structure to keep track of the unique start_times for every voice
            inx = 0
            start_time = 0 # start at the beginning of the piece - need one of these for each voice.
            current_duration = 0 # 
            for row in temp_array:
                  start_time += current_duration 
                  current_duration = row[1] # this is the 'start' column
                  temp_array[inx,1] = start_time
                  pt.scoreEvent(0, 'i', row)
                  inx += 1
      created voice as a dictionary, with sub-dictionaries for start_time as a dictionary with instrument names, and voice numbers
            voice = {'flute': {'start_time': 0,
                              'voice_number': 6},
                     'oboe': {'start_time': 0, 
                              'voice_number': 7}
                    } 
      I wonder if I should create a voice dictionary, with start_time and voice number        
---------------------
8/31/22 To do today

✅    Done of my recent work has anything to do with TonicNet since 8/5/22.
      I should create a separate folder for this project and share it on github.

✅    Run through the tutorial on Python Classes here: https://www.pythontutorial.net/
      It's very well done and simple to follow.
      I made a notebook to run the examples: Python_Class_Tutorial.ipynb
--------------------------------------
9/1/22 To do today:

✅    How big is the tonality diamond 
      Brute force in the notebook


----------------------
9/2/22 to do today:

✅    Revise the keys to read the ratios and steps from the cassandra.csv file 

✅    Revise the scale mask to use ratios instead of the 'Bb' notation.
      
✅    I've revised many of the dictionaries on the past few days, so here they are now:
      Indexes into the dictionaries
            mode is 'oton', 'uton' 
            ratio is a string: '1/1', '16/19', etc
            ratio_float is a floating point value 1.0, 1.25, etc.
            rank is 'A', 'B', 'C', 'D'
            chord_inversion is 1,2,3,4
            gliss_type is 'trills_2_step', 'trills_8_step', 'slide'
            instrument_name is a string describing an instrument like 'flute', 'oboe'

      Dictionaries
            keys[mode][ratio] data is 16 note scale steps in 256 tones per octave per f table 3 in the csd file
            scales[rank][mode] data is 8 steps to index into 16 note scales based on the rank and mode
            scale_mask[rank][mode][ratio] data is 0 or 1. Multiply by octave and add the result from a scale to obtain new scale in low to high order
            inversions[rank][mode][chord_inversion] data is the index into the 16 note scale step for 4 note chords 
            gliss[gliss_type][ratio_float] data is csound f table for this type of glissando
            voice_time[instrument_name]['start_time'] data is the start time for the next note to play in this voice. 
            voice_time[instrument_name]['voice_number'] data is the integer value for the voice in the csound csd file
            time_step_dict[] data is a set of rows for each column - I'm thinking I need something better than this.

      Functions to create structures
            def build_chords(mode, ratio, rank, inversion): # returns a 4 note chord
            def build_scales(mode, ratio, rank): # returns an 8 note scale
            def build_scale_mask(scale); # pass an 8 note scale and this function determines the ratios and returns a mask indicating 1 for need to boost the octave or 0 for no boost
            def ratio_string_to_float(ratio): # returns a floating point value from a ratio in string form: "16/9"
            def ratio_distance(start, end): # passed two ratios in string form returns a floating point ratio telling the ratio from on to the other
            def array_from_dict(time_step_dict): # passed a dictionary representing a set of notes with all columns, returns a numpy array that can be passed to ctcsound pt.scoreEvent(0,'i', array) for a note to play 
            def make_ftable_glissando(t_num, gliss_type, ratio): # passed a function table number, the type of gliss, and the ratio and returns the array to pass to ctcsound pt.scoreEvent(0,'f', array) to include in the time_step_dict['gliss']


---------------------
9/2/22 To do today:

☐     I really need a way to make this easier to use than manipulating dictionaries. Not scalable. 
      Remember how easy samples made it:
            d0h50&Bbmaj.u255&n1.g35 &n5.g33 &n9.g31 &n13.g29d50 # make a tetrad chord in Bb rank A, slide down, for 50 clicks, upsample 255 (-1) 
            d0h50&Bbmaj.u1&n3.g20 &n5.g18 &n9.g16 &n13.g14d50 # make a tetrad chord in Bb rank B, slide up, for 50 clicks, upsample 1
            @ Bbmaj would set the &n_. variables to the right tone value

☐     What would python classes do for me? A lot I think. It's easier to use than a dictionary, and does a whole lot more.
      Could I set some default values automatically?
      Could I call some function with just a few values, and have it fill out the dictionary for me? Or remember the last value and just use that for subsequent items? Kind of like an automatic '.' in a field in csound which means use the same value as the prior row. But I want the same value as the previous row of the same voice. Like a behavior if we don't specify a value it automatically uses the prior value for that voice. How can I make that behaviour work? 

----------------------------------
9/3/33 To do today:

✅    What if I started out with a very skinny csd file, and then passed the key function tables via ctcsound?
            f336 = (336, 0, 256, -7, 1, 16, 1, 128, 0.90000, 112, 0.90000) # g value 35 ratio 9/10
            pt.scoreEvent(0, 'f', f336)
            # it gets a warning message written to the log: 
                  WARNING: replacing previous ftable 330
            But it works.
            So what this means is I no longer need to prewrite the glissandi to the csd file, but even if I do, I can overwrite them. 
            And I can switch back to 213 tones per octave. This may take a while

      The current ball3.csd file structure:
            <CsoundSynthesizer> 
            <CsOptions> 
            -o dac
            ; -W -G -m2 -3 
            </CsOptions> 
            
            <CsInstruments> 
            ; here is where the instrument is defined
            <CsScore> 
            ; here is where the function tables are defined
            f0 2440 ; how long the piece is, how long ctcsound will stay alive waiting for commands to act upon
            ; cents for each step in the scale 217 partch tonality diamond to the 31-limit
            f3 0 256 -2 ...
            f4 0 1025 9 .25 1 0 ;The first quadrant of a sine for panning 
            f300 and up are the gliss tables: 2 step, 8 step, slide, slide with vibrato
            f526 - last gliss table
            f298 down to 261 - envelope tables
            f601 and up - sample file metadata and samples
            ; the next two are calculated by samples.pas to point to the location of the sample files and metadata
            f768 end of sample file metadata and samples.
            f1 0 64 -2 0 601 630 656 661 666 671 687 706 728 748 
            f2 0 64 -2 0 1 1 2 2 2 2 2 2 2 2

✅    I've created an f3 table that I can load after I start the "skinny" csd file. 
      But I'll need some pretty gnarly logic to link the ratios to the 213 tone scale degrees. Maybe I shouldn't remove the duplicates. But I might need to have them sorted. Maybe not. Give it a try. It works with 296 scale degrees not sorted in the f3 table. Neat.

✅    So I was able to recreate the keys[mode][ratio] dictionary with the items now pointing to the new f3 function table values 
      And once I send the f3_array_ready_to_load to Ctcsound it overwrites what is in ball3.csd. I made ball3.csd have the current f3_array_ready_to_load values, so it works by default.

---------------------------------------
9/4/22 To do today:

✅    Create new 'ranks' for all the other 8 note scales I can make from the oton or uton modes, like those identified in the microtonal spreadsheet. Lots of those require all both 'uton' and 'oton' notes, so those will be off limits for now. I made a stab at a subminor scale on oton, and one that doesn't have a 3:2 in 'uton'. I think a scale really needs the 3:2. This has broken a lot of other functions. I'll have to think about this some more. 

✅    Finish the ratio_table with all the steps. 
      Remember that ratio_strings.reshape(256,)[note] is a string. Created a function to turn it into a float.

✅    Something is wrong with the scale_mask numbers now. Now that I've reordered the f3 table, they are whack.
      The distance between note numbers doesn't really tell me anything, unless they are bigger than 256. 

--------------------------
9/5/22 To do today

✅    Replace some of the dictionaries with function calls. 
      Making the dictionaries is prone to failure. And if you can code what the dictionary should contain then you can code a function to deliver the answer. For example, the ratio_table. I coded up the content yesterday, but had to print the content, then cut and paste to make the dictionary. Error prone. Replaced with a simple calculation. Brilliant. 

✅    What other dictionaries would be better as functions? I think the scale mask could be replaced by a function that would provide a mask on demand.

✅    Perhaps I should return note to just an index into the f3 table. Use octave for what it says it should be.

✅    One of the things I've always done when looking for interesting scales is limit them to ones with at least one 3/2.
      See the ratios of each of these steps in oton and uton scales. I found some where the ratio was in ([3/2, 3/4]) those are:
            oton
            (0, 8): 3/2, (2, 11): 3/2, (4, 14): 3/2, (8, 2): 3/4, (12, 5): 3/4,
            uton
            (2, 8): 4/3, (5, 12): 4/3, (8, 0): 2/3, (11, 2): 2/3, (14, 4): 2/3, 

            Make sure the 3:2 is in position 5, not 6. 
            Next step is to play these on a keyboard and fiddle with the upper tones until you find something with character.

            otonal modes:
            A: [ 0  2  4  6  8 10 12 14 ]: 1/1 9/8	5/4	11/8	3/2	13/8	7/4	15/8	1/1	
            root: 1/1 third: 5/4 3rd ratio: 5/4 above root - this is already in scales['A','oton']
            B: [ 2,  4,  6,  8, 10, 12, 14,  0]:  9/8 5/4 11/8 3/2 13/8 7/4 15/8 
            C: [ 1,  3,  5,  7,  9, 11, 13, 15]:  17/16 19/16 21/16 23/16 25/16 27/16 29/16 31/16 
            D: [ 3,  5,  7,  9, 11, 13, 15,  1]:  19/16 21/16 23/16 25/16 27/16 29/16 31/16 17/17
            E: [  2,  4,  6,  8, 11, 13, 15,  0]: 9/8 5/4 11/8 3/2 27/16 29/16 31/16 1/1
            root: 9/8 third: 11/8 3rd ratio: 11/9 above root - this is almost the same as scales['B','oton'], but with a 3:2 11
            F: [ 8, 10, 12, 14,  0,  2,  4,  6]: 3/2	13/8	7/4	15/8	1/1	9/8	5/4	11/8	3/2	
            root: 3/2 third: 7/4 3rd ratio: 7/6 above root
            G: [ 4,  6,  8, 10, 14, 15,  0,  2]: 5/4	11/8	3/2	13/8	15/8	31/16	1/1	9/8	5/4	
            root: 5/4 third: 3/2 3rd ratio: 6/5 above root
            H: [12, 14,  0,  2,  5,  7,  9, 11]: 7/4	15/8	1/1	9/8	21/16	23/16	25/16	27/16	
            root: 7/4 third: 1/1 3rd ratio: 4/7 above root
            
            utonal modes:
            A: [ 8,  6,  4,  2,  0, 14, 12, 10]
            B: [14, 12, 10,  8,  6,  4,  2,  0]
            C: [13, 11,  9,  7,  5,  3,  1, 15]
            D: [15, 13, 11,  9,  7,  5,  3,  1]
            'E': [ 8, 6, 4, 2, 0, 15, 13, 11] # 3rd: 6:5 minor (8,4,0)
            'F': [ 0, 14, 12, 10,  8,  6,  4,  2] # 3rd: 8:7 subminor (0,12,8)
            'G': [14, 10,  8,  6,  4,  2,  0, 15] # 3rd: 5:4 major (14,8,4)
            'H': [5,  3,   1, 15, 12, 10,  8,  6]# 3rd: 21/17 neutral (5,1,12) G+, B-, D+
-------------------------------------
9/6/22 To do today

✅    I think I may have put too much weight on the distinction between ranks A & B and C & D. 
      After all, they are the same notes, just start at a different spot. For that matter, the scales above are just a different 8 note scale. They key difference is between notes in the 15-limt and those in the 31-limit diamond.
      So I created E, F, G, H from the interesting scales above. It was more than just flipping the otonal to make the utonal. Finding the 3rd and 5th was challenging. But I got it done and the notebook works now.

----------------------
9/7/22 To do today:

✅    I think I eliminated the array_from_dict function's ability to translate duration and hold into start_time and duration.
      I remember making that work, but now it's gone. I looked at one from 4 days ago, and it doesn't have that capability. I must have done it somewhere else. It was somewhere else. And it's linked to the ability to track each voice's current start time. I created a new function fix_start_duration_values(time_steps, voice_time["flute"]["start_time"]). It updates the voice_time dictionary during the process. I'm not happy with that structure. I don't really have that much information about a voice that I need to track. Right now it has the voice number and the current time. Anything else needed? If now, I should just track the current time for the voice.

✅    Csound doesn't work. It keeps coming back with this error:
            
            INIT ERROR in instr 1 (opcode oscili.kk) line 109: Invalid ftable no. 0.000000
            The real problem is invalid table no. 0. 
            Here is line 109: 
                  kcpsm2 oscili 1, 1/p3, i13 ; create a 2nd set of shift multiplicands from table - glissandi 2
                  p1          2           3           4     5           6     7           8           9           10
            ['instrument', 'duration', 'hold', 'velocity', 'tone', 'octave', 'voice', 'stereo', 'l_envelope', 'gliss1', 
                  11          12          13          14    15
            'upsample', 'r_envelope', 'gliss2', 'gliss3', 'volume'])
            I tried to shift it back to integers from floats, that didn't help. Switched it back. The problem was a 0 table.
            Once I tested the table against zero, I routed around the problem. There must have been a table 301 that existed in the old csd file. When I got rid of all the gliss tables, I probably took that one too. Now that I no longer subtract 301 from the g value, it was suddenly exposed as an error. Fixed it

-----------------------------------
9/8/22 To do today:

☐     I'm reading the csound manual sequentially. Interesting things are discovered
      ramping - https://csound.com/docs/manual/ScoreRamping.html for example a pitch will gradually ramp from one row to another with the < in place of a pitch value.
      #include "filename" - you can have one file that sets most of the default values and is called to imbed some text with one line. Neat. I could have really used that. For the last 20 years or so.
      voice - emulates the sound of a human voice - never tried that.
      sample playback signal generators: https://csound.com/docs/manual/SiggenSample.html
            a3 loscil 1, kcps2, iFtable, ibascps ; this is one I use for mono sampling with looping
      others: loscil3 - uses cubic interpolation - I don't know if I ever found an benefit from that. 
            loscilx - for multiple channel samples
            lposcil - high precision - I don't know if I ever tried that.
      printing - printk - https://csound.com/docs/manual/SigioPdisplay.html
      Limits: there used to be a limit of 200 tables. I blew through that 20 years ago. It is automatically extended. 

✅    ctcsound documentation. https://csound.com/docs/ctcsound/index.html
            csound magics https://github.com/csound/ctcsound/blob/master/cookbook/06-csoundmagics.ipynb
                  lets you run csound from a notebook
            API - scoreEvent(type, pfields)
                  https://csound.com/docs/ctcsound/index.html
                  type_ is the score event type (‘a’, ‘i’, ‘q’, ‘f’, or ‘e’). so what do they all mean?
                  csound manual under score statements: https://csound.com/docs/manual/ScoreStatements.html
                        a - advance score time a 0 start_advance - advance over silence, for example
                        i - instrument time, and duration, and other control statements 
                        q - quiet an instrument q instrument # 0 (muted)
                        f - table values created with GEN statements
                        e - mark the end of the last section 
                  By this I asssume I can pass f statements to csound to create glissandi dynamically
            I noticed that it doesn't talk about handling a t0 value to slow down and keep integer values. I don't need that any more because ctcsound supports floats just fine.

✅    I need to make sure that I have the right values reaching csound in terms of note and gliss. p5 & p10
            Solid match.

✅    I need to ajust fix_start_duration function to take the short name as input, instead of two values 
      instead of the current time and short_name just take the short name.

-----------------------
9/9/22 To do today:

✅    Noticed a problem with build_slides: 
            # the last slide is 1.875, which is from 14 (15:8) to 0 (1:1). I wanted 15:8 to 2:1.
            # how can I change the function build_slides to make that check and choose the nearest alternative?
            print(f'{scale_1[-1] = }, {all_ratio_strings[scale_1[-1]] = }')
            print(f'{scale_2[-1] = }, {all_ratio_strings[scale_2[-1]] = }')
      I think the problem can be best solved in the function ratio_distance.
            print(f'distance from {all_ratio_strings[15]} to {all_ratio_strings[1]} is {ratio_distance(all_ratio_strings[15], all_ratio_strings[1])} = {Fraction(ratio_distance(all_ratio_strings[15], all_ratio_strings[1])).limit_denominator(100)}')
            distance from 31/16 to 17/16 is 0.5483870967741935 = 17/31
            I want it to be smart enough to go to the nearest 17/16, which is 17/8 an octave up (or down from there.
            distance from 1/1 to 15/8 is 1.875 = 15/8 . I want it to go from 2/1 to 15/8. 
            Fixed it.

-------------------------------------
9/10/22 To do today:

✅    Create a python library with all the dictionaries and functions.
      This was harder than I expected. Again. I have to pass into the python code a lot of structures that were accessible in the notebook: keys, scales for example are defined in the diamond_music_utils.py, but not accessable from other functions. Perhaps it's because I define them in a function. Maybe. So I modified all the calls to pass them as parameters.
      Now I'm thinking it would be better to keep the dictionaries invisible to the notebook, instead have functions that return values. I wonder if I could use classes for this. 

✅    I pulled voice_time from the python library and put it in the notebook. 
      This dictionary will be different for every notebook. I think I'll have to pull the note dictionary also. I'm thinking I could replace it with a class. Maybe.
      So we now have two dictionaries in the notebook:
            voice_time[short_name] 'fpn', 'bnp', 'bdl', 'bdm', 'bdh', 'bfl', 'obo', 'cla', 'bss', 'frn'
            time_step_dict[] with a key = short name of the instrument, currently 'bfl' and 'bss' 

-------------------------
9/11/22 To do today:

✅    I need to remove the gliss tables to their own array. 
      Only store the table number with the note, not the whole function table itself. Solution is to have a function that stores up the functions that will be sent to csound until it's time to make music, then send them in bulk to the csound instance. 

✅    I need a way to reset the voice_time 'start' value. I thought I did this, but it still fails to reset the start time:
            dmu.show_voice_time()[bfl]["start"] = 78.00000000000001
            dmu.show_voice_time()[bss]["start"] = 65.625
      This was left over from a prior function in the diamond_music_utils.py library. I removed the function, but python must cache it somehow, because even though it was no longer in the library, it was still returning results. Closed the notebook and restarted jupyter. Fixed it: AttributeError: module 'diamond_music_utils' has no attribute 'show_voice_time'

-------------------------------------
9/12/22 To do today:

✅    Fixed yesterday's bugs.

✅    The function time_steps = dmu.fix_start_duration_values(winds, voice_time, ) fails. 
      It needs a voice_time[short_name]. What if I want to send several voices? I really should not need the short name. I can look inside time_step_array for the voice number, then through the voice_time to find the relevant to find that voice number, and set the start time accordingly. I've made many changes, and the current version is in the notebook.
      The problem is that instrument wipes out the prior note that was sent to the instrument. I'll need someplace to save a collection of notes.

--------------------------
9/13/22 To do today:

✅    dmu.build_slides returns all the table number built since the first call. 
      It should only return the elements from the current call to the function, not all of them. 
      Fixed that.

✅    3.    dmu.build_slides(tones_1, tones_2) keeps returning 4 additional slides with every invocation, now up to 44 of them.
            I had forgotten to set global stored_gliss in the dum.init_instrument function. So it was just initiating a local stored_gliss instead of the global one. Fixed it. We only need to use the global keyword in a function if we want to do assignments or change the global variable. global is not needed for printing and accessing. 
            Fixed that 
            Csound fails to use the slides, maybe because he gets passed 44 of them instead of just 4. 
            Fixed that problem by making sure I was using global before variables that are assigned values in a function.
                  grep -c "replacing previous ftable" ball3.log
                  84            
            Csound still fails to use the slides even after I fixed the problem where it was passed 84 of them. 
            What's up with that?
                  gliss_1 = array([800., 801., 802., 803.]) # that's correct - csound is ready to receive them
                  print(f'{round(row[8],3)}') # prints .9, .917, .929, .938 which are the right ftable values
                  # csound was sent the right ftables.
                  But the instrument doesn't assign them. When it gets to the 'i' being sent to csound, the row values in winds are not correct.
                  instrument, duration, hold, velocity, tone, octave, voice, stereo, l_envelope, gliss, upsample, r_envelope, gliss2, gliss3, volume 
                  ins sta hol vel ton oct voi ste env gli ups renv gl2 gl3 vol
                  [1,  0,  5, 60,  36,  4,  7,  8,  1,  0,  1,  1,  0,  0,  30]
                  [1,  0,  5, 60,  36,  4,  7,  8,  1, 800, 1,  1,  0,  0,  30] # fixed it.
                  The name in the instrument function for gliss in the arguments did not match the name in the np.array statement below it. Fixed it. But it still keeps increasing - there was another variable being assigned that was not set to global. Fixed that too.

✅    5. stored_gliss expects every table to have the same dimensions. All three have different dimensions. 
            Could I pad the shorter ones?
            gliss_f_table.shape = (4, 19) # this is trill_2_step 70 - 51
            gliss_f_table.shape = (4, 67) # trill_8_step 70 - 3 
            gliss_f_table.shape = (4, 11) # slide 70 - 11
            Padding works. Fixed it. 
✅    6. build_slides is still producing slides bigger than it should. It should always build the least distant slide. 
      I adjusted it as well as I could, but it still selects the best ratio distance and it's too far for good sound. 
      So I've listened to them all and arranged a dictionary called good_combos with the best.
      Systematically analyzing the possible glisses for 16/9 'oton' and came up with a problem. I can't remember what it was, but I fixed it.
---------------------------
9/14/22 To do today:

✅    What would you like the final piece to look like in terms of text on the page? 
      Build that, then figure out how to make the functions that will realize that structure.
      In fact, why not go back to the structure of the recent version of Balloon Drum Music and see how a separate thread for the winds could be implemented. 
      
✅    Should it be horizontal or vertical? 
            Horizontal writes out all the notes for one voice, then moves to the next voice
            Vertical spreads the information across all the instruments one time_step at a time. I'm going to start with that.
                  chord_1 = build_chords(mode, root, rank_1, inv_1)

✅    1. Finally figure out what dimension you want for the piece. 
            Traditionally, time series should have the time as the first dimension, and the samples as the second dimension. So that would be (time_step, features). My time steps can repeat, so they are not unique. If I have five notes, the dimensions should be (5,15). That's what I now have:
            winds.shape = (5, 15)
            But if I want the simply repeat that, how can I contatenate so that I have (10,15)
                  save_winds = np.empty((0,15), dtype = float) # do this once
                  save_winds = np.concatenate((save_winds, winds), axis = 0)
                  print(f'{save_winds.shape = }')
                  save_winds.shape = (10, 15)
            But that doesn't update the "start" times for the second chords
            After I've done this, all the notes appended to save_winds have the same start time as the previous winds, effectively doubling the voices. But what was inteneded was to bump up the newly added winds by the sum of the existing save_winds start times. It's like I should wait and send them all through at once instead of for each instrument. Or require that all newly added notes be added by sending them through instrument. Ban concatenation. After I finally figured out how to do it. Contatenate before sending notes through instrument.

✅    2.    Move the fixing of duration to start time to the instrument function. 
            Take care of this once and don't risk doing it again. Lots of side effects with this action 
      
✅    4. Now to deal with the smelly code in the calls to instrument.
            I need a way to call it more easily.     
            Perhaps I could make instrument handle multiple notes at a time. 
            What I want is the ability to quickly assemble some code that includes many chords with interesting rhythm. 
            Another idea: Create a bunch of different multi-instrument riffs, and choose among them randomly.

✅    5. This led to the systematic analysis of the glides available for rank 'A' & 'B', mode 'oton', and inversions 1,2,3,4.
            This is just a subset of the best_combos shape (32,4)
                  [ranks inversions]
                  ['A' 'A' '1' '2']
                  ['A' 'A' '1' '4']
                  ['A' 'B' '2' '1']
                  ['B' 'B' '3' '2']
                  ['B' 'B' '3' '4']
                  ['B' 'B' '4' '1']
                  ['B' 'B' '4' '3']
            Make these part of best_combos. This took a while, and some are still questionable. If I look closely, it's clear that going from A to B works only with the same inversion or one lower inversion. B to A same or in higher inversion.
            Same rank works for inversion one lower or higher.
            Same results for a variety of root notes. 
            For trills_8_steps, use these envelopes to limit the number of trills 
                  15: 1 up, down, up 
                  14: 2 down & up 
                  13: 4 down & up
                  12: 5 down & up 
                  11: 6 down & up
            Use the function choose_combo_trills() to retrieve a row of combo_trills

✅    A slide created on this mixture doesn't slide: 
      root = '16/9', mode = 'oton', rank_1 = 'A', rank_2 = 'A', inv_1 = 3, inv_2 = 3, dur = 2
      Well, the rank stays A and the inversion stays 3. Why is that, pray tell.
      Found it:
            inv_1 = int(note_dict['combo'][2])
            inv_1 = int(note_dict['combo'][3]) # this should have assigned it to inv_2 
      fixed it.

✅    Track the movement through the different functions and see if you can minimize assignment statements. 
      Keep as many of the same structures as it moves through the functions.
      Settle on a structure that can move seemlessly.
      If the original function is a dictionary, find ways to programatically add new entries to the dictionary.
      Make it possible to use multiples of each instrument. For example, bass flute is 'bfl'. Have another bass flute that is called 'bfx', which can be silent for a while, then join in as needed. 
      Or take advantage of duration 0 to stack multiple notes in the same instrument. 
      Perhaps keep it always zero and then go back through and add start_times.

✅    Flow:
      dictionary of notes which specifies much of what is needed in downstream functions. Is there a way to specify a function call as one of the dictionary values? Yes! 
            note_dict = {0: {'exec': chord_slide, 'mode': 'oton', 'root': '16/9', 'combo': choose_combo(), 'dur': 2, 'hold': 2, 'octv': 3, 'gliss_type':'trill_8_step', 'env': 1},
            temp = note_dict[inx]['exec'](note_dict[inx]) # calls chord_slide, passing note_dict, get an array back

      Then we call a function, which takes the dictionary as an argument.
            So we have a dictionary that I can load with values, including the function to call for those values. 
            We can have some values that are only relevant to some functions, and other to other functions.
            I need to build additional functions that do other interesting things.

      Each of those functions takes the dictionary as an argument. It must ends by calling the instrument function, which in turn updates the start values, stores the current global start values for each instrument. Instrument returns a complete note row ready to go to csound. Or stored in an array that can be saved up until you want to call csound.

✅    We now have three tiers:
      1. A dictionary called note_dict that specifies the functions and arguments that function requires and calls the functions. I can step through them sequentially or randomly 
      2. the function set that is called by #1 that receives note_dict and creates an array across all the instruments and calls the instrument function in tier 3
      3. the instrument function that updates the start time and loads an array ready for csound one voice at a time.

---------------------------
9/16/22 To do today:

☐     I'm worried that we may run out of function table numbers. Should I create a way to save those slides used many times?

☐     Next step is the build some more functions that the note_dict can call
      
✅    1. refine chord_slide to accept the number of repeats

✅    2. def chord_chop(note_dict) Short chop with env = 2, all instruments play a 4 note chord. 
            Make it repeatable for a certain number.
            That was complicated, because I couldn't use the np.repeat or np.tile to get it done.
            Or could I?
☐     3. Triads arpeggios switching instruments at random. Might be all, might be few, might be one. 
            what would you like: a four note arpeggio on one instrument, repeated on the next instrument, with a slight change, then the next until all have played it.
            I got it to work by delaying each of the voice starts by the dur times a delay value times the index into the instruments (starting at 0) So if I make the delay in the dictionary 4, then all the notes are continuous. But if it's less than 4 there is overlap. 
                  voice_time[note_dict["instruments"][v_num]]["start"] += dur[v_num] * note_dict["delay"] * v_num
            instruments[v_num * num_inst + inx]  is out of range if delay is 1
            I bumped it up by a factor of 2 and it seems ok now. Getting some interesting effects with delay of 1 and dur of .125, hold of .5. Delay can also be a float, but keeping track of time may be challenging.
            Now I'm thinking I have crammed too much function into this module. I'm going to create a simpler version that just plays a single hexad with variable repeats on just one instrument with repeats and no delay. 
            Still can't get the repeats to work in this one. 

✅    4. Simple hexad with masking. Kind of like arpeggios. Easiest so far.
            
☐     4. 8 note Scale from low to high including the root note at the start and end, held at the top. 
      Enable shifting left or right. np.roll(array, shift, axis = None)
      All the instruments playing all the notes, maybe with some masking like in simple_hexad

✅    5. Combination of trill numbers and envelope values to optimize the trill_8_steps.
      Cut them off at the right spot to create subsets
            For trills_8_steps, use these envelopes to limit the number of trills 
                  15: 1 up, down, up hit 1/6 the normal length 
                  14: 2 down & up 1/4 the normal length 
                  13: 4 down & up 1/2 the normal length 
                  12: 5 down & up hit and sustain 2/3 the normal length 
                  11: 6 down & up 3/4 the normal length
                  1:  8 down & up full length
            combo_trills = ([15, 4,20])                  
 
 ---------------------------
 9/17/22 To do today
      
✅    Bug in dmu.build_scale_mask(). 
      It only handles one octave at a time, and screws things up for multiple octaves. I don't like scales of 
      more than 2 octaves anyway.

☐     Make a decision:
      - Was the choice of sending one note at a time to convert duration into start time correct or should I keep it in the duration format for longer through the process?
      - In favor of keeping it as is: Don't make changes unless you are certain it is the wise choice
            This format makes it easier to align several voices to do one task together, for example a chord slide using all the instruments.
            I'm working through the troubles, and may not change after all.

      - Opposed to keeping it as is: Today, once I have converted from duration into start time I can no longer use any of the numpy functions to modify the string of notes. No way to reorder, stretch, shrink, repeat, tile, or otherwise transform it once the start time is attached to the note. It's forever going to start at that time, or I'll have to go through complex processes to revise the note start times, outside of numpy.
      - Tiles always duplicate exactly. I'd like to roll between tiles. 

      What I have decided to do is to delay the conversion to start time from duration to later in the process. Perhaps during the write to csound or earlier. 

      I have duplicates the current notebook, called Diamond_music_utils.ipynb, as a new notebook Diamond_music_whisper_song.ipynb, and I will make that notebook the one with the delayed conversion of duration to start_time. I made Diamond_music_whisper_song-temp.ipynb to contain some fixes to Diamond_music_whisper_song.ipynb. 

✅    I'm working on that now. 
      I don't think it's quite getting the start times and durations correctly, and it's still letting the 0 hold notes through to csound. It should cut them off before going out.

      I can't figure out how this function is failing:
            winds.shape = (45, 15)
            fixed_winds.shape = (27, 15)
            Fixed it. I limited the return function to just those that belonged.
                  return note_array[:note_num,:]
      
      But it still messes up the start times. Here is how I used to do it.

            current_time = voice_time[voice_name]["start"] # what is this voice's current start time
            next_note[1] = current_time # overwrite column 1 (duration) with the new start_time
            return next_note
      I was using the hold time [2] instead of the dur [1] value
      I'm getting closer, but when I decrease the density, which causes more notes to have 0 hold time, the timing gets bad. I gave up trying to not copy the notes with 0 hold time, and just sent them through. Let csound sort it out. 

----------------------------------
9/18/22 To do today

✅    Make all the functions called from the dictionary much simpler. 
      Remove all tthe masks, repeats, and repeat with slight changes to downstream activities. 
            def scale_arpeggio(note_dict):
            def simple_hexad_arpeggio(note_dict): 
            def chord_chop(note_dict):
            def triad_arpeggio(note_dict): # it's not a triad, the the simple hexad arpeggio does everything I need
            def chord_slide(note_dict):
      See if you can't consolidate. For example, do you really need triad_arpeggio? simple hexad arpeggio is really the same thing. And remove all the mods except flip and roll, and I'm not really fond of roll. If you want a different mode then choose a different rank and be done with it. flip is ok for scales.

✅    Clean up fix_start_times so that you won't make the same mistakes again. 
      start and duration must be set to column 1, hold is not touched in column 2. 

✅    There appears to be a bug in dmu.build_scale_mask() Pass it a scale      
            The down one is complicated. I'm not thinking straight. Just take the up and flip it. easy-peasy.
            tones_1 = dmu.build_scales('oton', "16/9", "A")
      It started working correctly after I changed a few variables, but it's still wrong now. Fixed it. Wasn't updating prev_note with the previous note, retaining the first assignment. Fixed it.
      Now build_scales is broken. Sometimes it builds the scale starting at the C 1/1 at position 2. 
            array(['1/1', '10/9', '11/9', '4/3', '13/9', '14/9', '5/3', '16/9', '1/1'],
            You fool, that's because the rank passed from the dictionary is rng.choice(['A','B'])
            That's the B rank!
            Fixed.

✅    Now I'm suspicous of build_slides. It came back with array pf all four the same number. Not good.
            array([1.28571429, 1.28571429, 1.28571429, 1.28571429])
      That is to be expected moving from one mode to another inversion the same. They all move the same distance.
      Don't panic.

------------------------------
9/20/22 To do today:         

2.    Is there some way to limit the number of arguments passed so that defaults can be set and forgotten? 
      At this point 3/4 of the function lines are dedicated to assignment statements. I hid the problem in an array. 

✅    I need a systematic search of all the slides to minimize the maximum distance, defined as more than 1.3 or less than 0.75
      So I completed this task, and it suggests the best pair of chords and inversions to use based on minimized movement. But then I need a way to choose the next pair of chords and inversions. 
      So I'm partially finished with this effort. I have the list of inversions that include only slides that are betwen 8/7 and 7/8. Now I want to pick the best. So I look at the sum of cents differences, and for each inversion pair the differences in sum of cents are the same. Why? Is that just the reality? or something more sinister? Since I am selecting for narrow range of potential slides already, and tossing out the outliers, I'm left with only the inversion pairs that have the smallest sum of cents. I increased the range, and started getting different sum of cent values. So I guess it's not sinister at all.
      So next I need to choose the one with the high note that is closest to the next high note. But if I look at the high notes, they are all the same for all the inversions. This makes sense, since the four notes are exactly the same. 
      The only difference is the order of the notes. But the octave can be the maker. So, basically I don't need the inversion, except that the inversion dictates the order of the notes, which in turn dictates the octave mask. I bet if I don't use the octave mask, the inversions will all be the same. Amazingly simple solution. 
      So, in the end, if I get rid of the octave mask, I no longer care about the inversion! 
      But I didn't predict that outcome when I started this process yesterday. And I now know which pair of inversions results in the lowest cent distance. And they sound super. 

✅    I'd like to be able to double up the chord_slide notes so that they cover more octaves. 
      I could call it twice, but the second time would start later. What happens now in instrument function? Basically it just returns a numpy array of features for a note. It doesn't do the start time. So I could double at some point, if I don't increase the duration values. Do it 13 times, and in the 3rd iteration, then include the durations.
      I could do it in the loop that does all the note_dictionary values. I did that. Or I could the function into the chord_slide, where note_dict['octv'] if it's an array, we iterate over it, supressing the duration to 0 until the last iteration. builde the note_dict["octv"] array as an array. If it has only one value, will it work? It does indeed. Nice. 
      assert (octv.shape[0] == repeats), f'shape of octave {octv.shape = }, must equal number of {repeats = }'
      'octv': octv, 'repeats': repeats,

------------------------------
9/21/22 - 9/22/22 To do today:     

1.    Make a function that can slide between three or more chords. Why stop at two?   
            def multiple_chord_slide(note_dict):      
      I suppose I should store each chord in an array instead of tones_1, tones_2, etc.
      So I was able to make a list comprehension out of the bridge_chords dictionary and dmu.build_chords(mode, ratio, rank)
      THe key to getting this to work is the start at the end and work your way forward. Check every step to make sure it is returning what you expect.
      
      What I ended up with: 
            array_of_chords = np.array([(dmu.build_chords(items["mode"], items["ratio"], items["rank"],1)) for items in [bridge_chords[chords][0] for chords in bridge_chords]])
      Start with the end:
            print(f'{[chords for chords in bridge_chords]}')   
                  [0, 1, 2, 3, 4, 5, 6, 7, 8]
      index bridge_chords with chords:
            print(f'{[bridge_chords[chords] for chords in bridge_chords]}')    
                  [{0: {'mode': 'oton', 'ratio': '16/9', 'rank': 'A'}, 1: {'mode': 'oton', 'ratio': '8/7', 'rank
      index bridge_chords[chords] with [0], since you only care about the first of two chords in the dictionary
            print(f'{[bridge_chords[chords][0] for chords in bridge_chords]}') 
                  [{'mode': 'oton', 'ratio': '16/9', 'rank': 'A'}, {'mode': 'oton', 'ratio': '8/7', 'rank': 'A'}, ...
      Step through that list of rows, where each row is a dictionary which can be indexed by ['mode'], ['ratio'], ['rank']
            print(f'\n{[(items["mode"], items["ratio"], items["rank"]) for items in [bridge_chords[chords][0] for chords in bridge_chords]]}')
                  [('oton', '16/9', 'A'), ('oton', '8/7', 'A'), 
      Now pass those items to dmu.build_chords and you get notes back
            print(f'\n{[(dmu.build_chords(items["mode"], items["ratio"], items["rank"],1)) for items in [bridge_chords[chords][0] for chords in bridge_chords]]}')
                  [array([32, 36, 40, 44]), array([192, 196, 200, 204])
      Then turn them into a numpy array that can be passed to the next function
            print(f'\n{np.array([(dmu.build_chords(items["mode"], items["ratio"], items["rank"],1)) for items in [bridge_chords[chords][0] for chords in bridge_chords]])}')
                  [[ 32  36  40  44]
                  [192 196 200 204]
                  [194 130  66   2]
                  [224 228 232 236]
                  [192 128  64   0]
                  [  0   4   8  12]
                  [204 140  76  12]
                  [206 142  78  14]
                  [ 32  36  40  44]]
            array_of_chords.shape = (9, 4)
            
      And voilà! We have the list of chords that I'd like to slide through with one ftable. Wish me luck.
      I also need the inversion for each chord, otherwise it will go all over the place.
            
            right_inversions = np.array([[2, 1, 2, 2, 1, 1, 1, 1, 2], [1, 3, 3, 3, 2, 1, 2, 2, 1], [3, 1, 1, 2, 1, 2, 3, 1, 3]])
            which_inversion = rng.integers(3)
            print(f'{which_inversion = }')
            array_of_chords = np.array([dmu.build_chords(bridge_chords[chords][0]["mode"],bridge_chords[chords][0]["ratio"], bridge_chords[chords][0]["rank"], right_inversions[which_inversion, chords]) for chords in bridge_chords])

            print(f'{array_of_chords.shape = }\n{array_of_chords = }')
            
            this shows each of the four paths through the array that minimizes the ratio distance of all the notes.
            I bet I could code up a list comprehension that would produce this. In a few hours.
            It doesn't seem to improve things beyond a random selection.
            Optimum choice one gets me to 8,054 cents. What is the maximum ratio distance in each? 
                  fl_set      max   sum of cents
                  3           1.29  8054.6
                  2           1.45  9268.4
                  1           1.29  8054.6
                  0           1.45  9268.4
            So the best route is with fl_set in (1,3) except I'm finding better ones when I run random inversions, like this one:
                 
            Wait a minute. Is the dmu.ratio_distance the actual distance or does it count on being able to take a shortcut by changing the octave? If you set find_closest=False it doesn't do that check. What does the slide building function do? I think I always prefer the shortcut regardless. It doesn't need to switch octaves during the slide obviously. It just takes the shortest distance to the next note up or down an octave.
            So I ran 1000 times through the random selection and found several that were much better than the hand torn ones. Here's one: 
            
            last_run = 3610.8 cents changed. 0
               2   1   2   2   1   1   1   1   2
            [ 36 192   2 228 192   0 204 206  36]
            [ 40 196 194 232 128   4 140 142  40]
            [ 44 200 130 236  64   8  76  78  44]
            [ 32 204  66 224   0  12  12  14  32]

            Here is another that totals 4036 cents 1
               1   3   3   3   2   1   2   2   1
            [ 32 200  66 232   0   0  12  14  32]
            [ 36 204   2 236 192   4 204 206  36]
            [ 40 192 194 224 128   8 140 142  40]
            [ 44 196 130 228  64  12  76  78  44]

             last_run = 4161.4 - not much different from the previous one
               1   3   3   1   2   1   2   2   1
            [ 32 200  66 224   0   0  12  14  32]
            [ 36 204   2 228 192   4 204 206  36]
            [ 40 192 194 232 128   8 140 142  40]
            [ 44 196 130 236  64  12  76  78  44]
           
                 last_run = 4237.9]
               3   1   1   2   1   2   3   1   3    2         
            [ 40 192 194 228 192   4  76 206  40]
            [ 44 196 130 232 128   8  12 142  44]
            [ 32 200  66 236  64  12 204  78  32]
            [ 36 204   2 224   0   0 140  14  36]
       
            All the inversions:
            inversions = 1
            [ 32 192 194 224 192   0 204 206  32]
            [ 36 196 130 228 128   4 140 142  36]
            [ 40 200  66 232  64   8  76  78  40]
            [ 44 204   2 236   0  12  12  14  44]
            inversions = 2
            [ 36 196   2 228   0   4  12  14  36]
            [ 40 200 194 232 192   8 204 206  40]
            [ 44 204 130 236 128  12 140 142  44]
            [ 32 192  66 224  64   0  76  78  32]
            inversions = 3
            [ 40 200  66 232  64   8  76  78  40]
            [ 44 204   2 236   0  12  12  14  44]
            [ 32 192 194 224 192   0 204 206  32]
            [ 36 196 130 228 128   4 140 142  36]
            inversions = 4
            [ 44 204 130 236 128  12 140 142  44]
            [ 32 192  66 224  64   0  76  78  32]
            [ 36 196   2 228   0   4  12  14  36]
            [ 40 200 194 232 192   8 204 206  40]
      
      So, back to writing the multislide function
      How many slides are needed? One. How many steps in that slide if there are 9 chords?
      For example, suppose you were to build an ftable slide to cover these notes:
            [ 32 200  66 232   0   0  12  14  32]
      step      1   2   3   4   5   6   7    8
      Each step travels for each_f_step to reach the new destination and stays there for each_f_step
      So that's 8 steps of 128 time 2 each for 2048 total steps. 
      So why do we end up with 1792 steps? That's 7 * 256. Why 14? here was a bug when two notes are the same from one note to the next. I fixed it.

-----------------------------
9/23/22 To do today:

✅    Get the long slide module working. 

✅    The dmu.retrieve_gliss_tables(): now returns a 3 dimensional table. This is new. 
      Somehow I've added a dimension with the work I did for build_multiple_slides.
            print(f'{dmu.retrieve_gliss_tables().shape = }') 
      errors out with AttributeError: 'tuple' object has no attribute 'shape'
      So it's a tuple not a numpy array. 
      Track it through multiple_chord_slide:
            print(f'{stored_gliss_table.shape = }') # (0,70) 
            print(f'{current_gliss_table = }') # 800
            gliss_f_table = np.array([build_voice_slide(current_gliss_table + inx, array_of_chords.T[inx]) for inx in np.arange(voice_count)])
            current_gliss_table = current_gliss_table + voice_count
            print(f'{gliss_f_table[:,0] = }') # array([800., 801., 802., 803.])
            print(f'{gliss_f_table.shape = }') # (4, 37)
            gliss_f_table = np.concatenate((gliss_f_table, pad_gliss), axis = 1) # is this the right axis?
            print(f'{gliss_f_table.shape = }, {pad_gliss.shape = }') (4,70), (4,33)
            stored_gliss_table = np.concatenate((stored_gliss_table, gliss_f_table)) # this is a global variable.
            print(f'{stored_gliss_table.shape = }') (4,70)
            gliss = gliss_f_table[0]
            print(f'{gliss.shape = }') # (4,) <-- fixed this. it was (70,0)
      At every step it's the shape it should be: (4,70) then suddenly dmu.retrieve_gliss_tables returns a tuple of the (4,70) array and the number 804. How did that 804 get into the array?
            current_gliss_table = dmu.update_gliss_table(stored_gliss_table, current_gliss_table)
            print(f'{current_gliss_table = }') # 804
            print(f'{dmu.retrieve_gliss_tables()[1] = }') # 804 <-- what's that doing there.
      The problem was that dmu.retrieve_gliss_tables(): returns two values. I forgot that fact. 
            def retrieve_gliss_tables():
                  global stored_gliss 
                  global current_gliss_table 
                  return stored_gliss, current_gliss_table # <-- returns a tuple. Doh! Fixed it. Have to remember to always get two values from dmu.retrieve_gliss_tables()

✅    Why is there a 20 second delay before the start of the slides? 
      It was because I had not initialized the voice_start_time. Fixed it. 
      Now when I choose multiple octaves, it plays each one after than other, instead of simultaneously.
      Had to set duration to zero. That doesn't seem right. I added the code that does the automatic 0 of the first durations, so that each octave overlaps.

--------------------------
I took a detour and finally figured out how to get code-server to work. I now have vscode on the web on two machines, my T480 and the HP800. But I can't reach it from another machine, only on the one running code-server. Jupyter allows access. Let's see. 
-------------------------------
9/24/22 To do today:

✅    Holy Cow. Now ctcsound is failing to load.
      It had an error message I haven't seen in months: (actually not since January 14: https://forum.csound.com/t/re-csnd-a-couple-of-questions-about-csound-and-python/644)                       
            OSError: libcsound64.so: cannot open shared object file: No such file or directory
            One suggestion: https://github.com/csound/ctcsound/issues/6
                  You should create a symlink to libcsound64.so.6.0 in usr/lib:
                  cd /usr/lib
                  sudo ln -s libcsound64.so.6.0 libcsound64.so

                  It's a cleaner way.

                  Then the Attribute error is due to the fact that the csoundCompileTreeAsync method didn't exist in Csound6.09.01. You should use the ctcsound.py file shipped within the apt package instead. The ctcsound.py file in the github repo is synced with the develop branch of Csound and thus it can refer to methods that don't exist in earlier versions of Csound.
            Another suggestion from Victor_Lazzarini: I think you are just missing the symlink. Some linux distros only install these with the dev packages. You could either create the symlink yourself or install csound-dev (or whatever it is called).
            Fixed it. I started the jupyter lab up before entering the toolbox csound and activate gym. Remember that step next time.

✅    Well, I have to say it sounds terrible. 
      Here's what I'm using for the inversions used across the bridge_chords in the long slide:
            right_inversions = np.array([[2, 1, 2, 2, 1, 1, 1, 1, 2], [1, 3, 3, 3, 2, 1, 2, 2, 1], [3, 1, 1, 2, 1, 2, 3, 1, 3]]) # the 3rd one is bad. Try this one: [4, 2, 1, 3, 4, 3, 4, 3] Terrible.
      I get the sneaking suspicion that it gets the wrong ratios. Keep track of the maximum movement and print it out.It sounds good for the first two chords, and then goes whack.  I need to go back to the good_slides array and see what they sound like. Perhaps it was because I did not exclude any ratios outside the range that I used for good_slides, which was that the ratio_distance had to be between 7/8 and 8/7. There are a few ways I can investigate this:
      
      a. shorten up the time of the slide from 128 steps to 0 steps and see what it sounds like. It resulted in total silence. I have to do more research. I set each_f_step to 0, and that wrecked the structure. 
      
      b. take another look at good_slides: 
            good_slides - an array of slides to use in the bridge to cycle through the bridge chords
                  values are [0] - chord number index into the dictionary bridge_chords. Points to a pair of chords.
                        [1] inversion for the starting chord 
                        [2] inversion for the ending chord  
            It's very suspicious that all the best ones had optimal times of exactly 329.9 as the sum of the absolution value of cents distance traveled. Weird. 
            I rewrote all the code and got the same answer. 
    
      c. Something is wrong when the which_inversion is zero. right_inversions[which_inversion] is screwing everythin up for some reason 
            if which_inversion == 0:
                  print (f'{right_inversions[which_inversion] = }') Fixed it.

      d. I should be tracking the distance each voice travels in total, not the sum of each chord change. I may find a difference there.
            Here is the journey that one voice took: total_f_steps = 2048.0
              This says that some voices traveled 702 at the max. That should not happen. What is going on?
            So I was able to build an array of arrays one for each inversion, but I am having trouble building voices that can take any path through that array
      
            Here they are in a nice compact array. I could try to figure out what each inversion is, but that's prone to error. 

            Here are all the inversions where all the notes have the same inversion.
            inversions = 1
            [ 32 192 194 224 192   0 204 206  32]
            [ 36 196 130 228 128   4 140 142  36]
            [ 40 200  66 232  64   8  76  78  40]
            [ 44 204   2 236   0  12  12  14  44]
            inversions = 2
            [ 36 196   2 228   0   4  12  14  36]
            [ 40 200 194 232 192   8 204 206  40]
            [ 44 204 130 236 128  12 140 142  44]
            [ 32 192  66 224  64   0  76  78  32]
            inversions = 3
            [ 40 200  66 232  64   8  76  78  40]
            [ 44 204   2 236   0  12  12  14  44]
            [ 32 192 194 224 192   0 204 206  32]
            [ 36 196 130 228 128   4 140 142  36]
            inversions = 4
            [ 44 204 130 236 128  12 140 142  44]
            [ 32 192  66 224  64   0  76  78  32]
            [ 36 196   2 228   0   4  12  14  36]
            [ 40 200 194 232 192   8 204 206  40]
            best_bridge_chord_array[0]:
            inversions
               1   4   2   1   2   4   1   1   2
            [ 32 204   2 224   0  12 204 206  36]
            [ 36 192 194 228 192   0 140 142  40]
            [ 40 196 130 232 128   4  76  78  44]
            [ 44 200  66 236  64   8  12  14  32]

            These all sound terrible. Something must be wrong with my slides. Fixed it.
            voice #1: 
            
            gliss function tables:  
             +--table num
             |      +--start at 0
             |      |    +--points in table
             |      |    |        +--gen07
             |      |    |        |    +--start at 1:1, or in this case 16/9
             |      |    |        |    |    +--take 128 to reach next target
             |      |    |        |    |    |      +--target ratio. go up 9/8 to 1:1
             |      |    |        |    |    |      |                           +--target ratio. go up 9/8 to 9/8
             |      |    |        |    |    |      |                           |                           +--down 73/77 to 16/15
            [800.0, 0.0, 2048.0, -7.0, 1.0, 128.0, 1.125, 128.0, 1.125, 128.0, 1.125, 128.0, 1.125, 128.0, 0.948, 128.0, 0.948, 128.0, 0.938, 128.0, 0.938, 128.0, 0.875, 128.0, 0.875, 128.0, 1.143, 128.0, 1.143, 128.0, 1.071, 128.0, 1.071, 128.0, 1.037, 128.0, 1.037]

            I think the problem is an extra .T or a missing .T. It was the latter. Works now, but it still sounds a little weak. 
            
------------------
9/27/22 To do today:

1.    Find a way to combine several of the "bridge_chord_array":  rng.integers(best_bridge_chord_array.shape[0])
      When I try multiple instances that would overlap, it's not right at all. Each is wrong in its own way. Something is whack with the ratios.
      Then it occasionally comes together. This makes me think it's not picking the right notes. I created ball4.csd to test out ideas. I was able to reduce the slide duration and increase the hold durations of the slides. Now I can more clearly hear that it's not making the right notes.
      
2.    Combine over 45 seconds the note_array function and the multiple_chord_slide funtion.
      Make it so the both go through the nine chords at the same speed.

3.    Build an analog to build_scale_mask(scale): 
      Goal: find a way to ensure that the current chord is as close to the previous chord as possible.
      a. Compare all the notes and help out those below a mid-point and not those above the mid-point. 
      b. Take in two chords and build a mask for the second that makes it closer to the first. 

4.    Get serious about drastically lowering the amount of choices that need to be made for each note.
      a. Take a look at note_dict and see what can be remembered from one call to another.
      b. Use csound's built in . value to use the previous notes arguments.
      c. Build a different structure that looks more like my Pascal samples program input. 
      d. Don't change the structure, but find a way to automate the building of note_dict structures.

5.    Did you know that it's imporant for the final element in the gen07 function table is the last ratio, not a duration. 
      And you can make it bigger than the size of the array and it will just truncate them. If it's too small, it will pad with zeros. 

6.    Wwhat if I ignored direction when ratio_distance was called to provide the ratio to arrive at the next note.
      What if I sometimes need to send the note in the other direction. If you were inside the code, what would you do now?
      Get out the pencil and paper and make sure the ratios are right. Now I have been able to build a csd file that simultaneously plays the chords and the slides. After a few notes, they diverge.
      I figured out the problem. I was assuming that the ratio changes were cumulative. 1.125 followed by another 1.125 would increase a second time. No. It just means it is 1.125 above the initial pitch. I need to make each ratio relative to the starting note.
      ratio_distance from the start, not the prior note. Greatly improved results, but not perfect. I need to take the ball4.csd and test every single voice. The first one is great for almost to the end, then diverges. It looks like the discrete pitches are where the mistake happens. I fixed it. Only it seems to cut off the last chord. I can add 120 more to the final duration. Didn't help.
                                 1:1         1:1        9:10       9:10        
      [800.0, 0.0, 2048.0, -7.0, 1.0, 181.0, 1.0, 60.0, 0.9, 181.0, 0.9, 60.0, 1.0125, 181.0, 1.0125, 60.0, 0.96, 181.0, 0.96, 60.0, 1.0285714, 181.0, 1.0285714, 60.0, 1.125, 181.0, 1.125, 60.0, 1.05, 181.0, 1.05, 60.0, 0.9642857, 181.0, 0.9642857, 60.0, 1.0, 181.0, 1.0, 120.0, 1.0]
      I'll just have to follow with a chord on 16/9 oton rank A. It's challenging to get the timing right. 
      I'd also like to make sure I have the best slide choices.
      Here are the choices: These are all the same!
      1     ind = 0
            chosen_array = 0, [[ 32 204   2 224   0  12 204 206  36]
            [ 36 192 194 228 192   0 140 142  40]
            [ 40 196 130 232 128   4  76  78  44]
            [ 44 200  66 236  64   8  12  14  32]]
      0     ind = 1
            chosen_array = 1, [[ 36 192 194 228 192   0 140 206  36]
            [ 40 196 130 232 128   4  76 142  40]
            [ 44 200  66 236  64   8  12  78  44]
            [ 32 204   2 224   0  12 204  14  32]]
      0     ind = 2
            chosen_array = 2, [[ 44 196 194 228 192   4 140 142  40]
            [ 32 200 130 232 128   8  76  78  44]
            [ 36 204  66 236  64  12  12  14  32]
            [ 40 192   2 224   0   0 204 206  36]]
      1     ind = 3
            chosen_array = 3, [[ 32 200  66 236  64  12  12  78  44]
            [ 36 204   2 224   0   0 204  14  32]
            [ 40 192 194 228 192   4 140 206  36]
            [ 44 196 130 232 128   8  76 142  40]]
            ind = 4
            chosen_array = 4, [[ 36 204   2 224 192   4 140 206  36]
            [ 40 192 194 228 128   8  76 142  40]
            [ 44 196 130 232  64  12  12  78  44]
            [ 32 200  66 236   0   0 204  14  32]]
            ind = 5
            chosen_array = 5, [[ 32 204  66 236  64  12  12  78  44]
            [ 36 192   2 224   0   0 204  14  32]
            [ 40 196 194 228 192   4 140 206  36]
            [ 44 200 130 232 128   8  76 142  40]]
            ind = 6
            chosen_array = 6, [[ 36 204   2 224   0  12 204  14  32]
            [ 40 192 194 228 192   0 140 206  36]
            [ 44 196 130 232 128   4  76 142  40]
            [ 32 200  66 236  64   8  12  78  44]]
            ind = 7
            chosen_array = 7, [[ 40 196 130 232 128   8  76  78  44]
            [ 44 200  66 236  64  12  12  14  32]
            [ 32 204   2 224   0   0 204 206  36]
            [ 36 192 194 228 192   4 140 142  40]]
            ind = 8
            chosen_array = 8, [[ 40 196 130 232 128   8  76  78  44]
            [ 44 200  66 236  64  12  12  14  32]
            [ 32 204   2 224   0   0 204 206  36]
            [ 36 192 194 228 192   4 140 142  40]]
            ind = 9
            chosen_array = 9, [[ 32 200 130 232  64   8  76 142  40]
            [ 36 204  66 236   0  12  12  78  44]
            [ 40 192   2 224 192   0 204  14  32]
            [ 44 196 194 228 128   4 140 206  36]]
            ind = 10
            chosen_array = 10, [[ 32 204  66 236  64   8  12  14  32]
            [ 36 192   2 224   0  12 204 206  36]
            [ 40 196 194 228 192   0 140 142  40]
            [ 44 200 130 232 128   4  76  78  44]]
            ind = 11
            chosen_array = 11, [[ 40 192   2 224   0   0 204 206  36]
            [ 44 196 194 228 192   4 140 142  40]
            [ 32 200 130 232 128   8  76  78  44]
            [ 36 204  66 236  64  12  12  14  32]]
            ind = 12
            chosen_array = 12, [[ 36 204   2 224   0  12  12  14  32]
            [ 40 192 194 228 192   0 204 206  36]
            [ 44 196 130 232 128   4 140 142  40]
            [ 32 200  66 236  64   8  76  78  44]]
            ind = 13
            chosen_array = 13, [[ 36 204   2 224 192   0 204 206  36]
            [ 40 192 194 228 128   4 140 142  40]
            [ 44 196 130 232  64   8  76  78  44]
            [ 32 200  66 236   0  12  12  14  32]]
            ind = 14
            chosen_array = 14, [[ 40 196 194 228 192   0 204 206  36]
            [ 44 200 130 232 128   4 140 142  40]
            [ 32 204  66 236  64   8  76  78  44]
            [ 36 192   2 224   0  12  12  14  32]]
            ind = 15
            chosen_array = 15, [[ 32 204   2 224 192   4  76 142  40]
            [ 36 192 194 228 128   8  12  78  44]
            [ 40 196 130 232  64  12 204  14  32]
            [ 44 200  66 236   0   0 140 206  36]]
            ind = 16
            chosen_array = 16, [[ 36 204   2 224 192   4  76  78  44]
            [ 40 192 194 228 128   8  12  14  32]
            [ 44 196 130 232  64  12 204 206  36]
            [ 32 200  66 236   0   0 140 142  40]]
            ind = 17
            chosen_array = 17, [[ 36 204  66 236  64   8  76  78  44]
            [ 40 192   2 224   0  12  12  14  32]
            [ 44 196 194 228 192   0 204 206  36]
            [ 32 200 130 232 128   4 140 142  40]]
            ind = 18
            chosen_array = 18, [[ 40 196 130 232 128   8  12  78  44]
            [ 44 200  66 236  64  12 204  14  32]
            [ 32 204   2 224   0   0 140 206  36]
            [ 36 192 194 228 192   4  76 142  40]]
            ind = 19
            chosen_array = 19, [[ 40 192 194 228 192   0 204  14  32]
            [ 44 196 130 232 128   4 140 206  36]
            [ 32 200  66 236  64   8  76 142  40]
            [ 36 204   2 224   0  12  12  78  44]]
            ind = 20
            chosen_array = 20, [[ 44 200  66 236  64   8  76  78  44]
            [ 32 204   2 224   0  12  12  14  32]
            [ 36 192 194 228 192   0 204 206  36]
            [ 40 196 130 232 128   4 140 142  40]]
            ind = 21
            chosen_array = 21, [[ 36 192   2 224   0   0 204 206  36]
            [ 40 196 194 228 192   4 140 142  40]
            [ 44 200 130 232 128   8  76  78  44]
            [ 32 204  66 236  64  12  12  14  32]]
            ind = 22
            chosen_array = 22, [[ 44 196 130 232  64   8  76 142  40]
            [ 32 200  66 236   0  12  12  78  44]
            [ 36 204   2 224 192   0 204  14  32]
            [ 40 192 194 228 128   4 140 206  36]]
            ind = 23
            chosen_array = 23, [[ 32 200 130 232 128   4  76  78  44]
            [ 36 204  66 236  64   8  12  14  32]
            [ 40 192   2 224   0  12 204 206  36]
            [ 44 196 194 228 192   0 140 142  40]]
            ind = 24
            chosen_array = 24, [[ 40 192 194 228 128   4  76  78  44]
            [ 44 196 130 232  64   8  12  14  32]
            [ 32 200  66 236   0  12 204 206  36]
            [ 36 204   2 224 192   0 140 142  40]]
So, now that I have fixed the slide 