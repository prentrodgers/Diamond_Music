 I've revised many of the dictionaries on the past few days, so here they are now:
      Indexes into the dictionaries
            mode is 'oton', 'uton' 
            root is a string: '1/1', '16/19', etc
            ratio_float is a floating point value 1.0, 1.25, etc.
            rank is 'A', 'B', 'C', 'D'
            chord_inversion is 1,2,3,4
            gliss_type is 'trills_2_step', 'trills_8_step', 'slide'
            instrument_short_name is a string describing an instrument like 'bfl', 'bss'in the voice_time dictionary in the notebook
            all_ratio_strings = ratio_strings.reshape(256,)

      Dictionaries in the diamond_music_utils.py
            keys[mode][ratio] data is 16 note scale steps in 256 tones per octave per f table 3 in the csd file
            scales[rank][mode] data is 8 steps to index into 16 note scales based on the rank and mode
            inversions[rank][mode][chord_inversion] data is the index into the 16 note scale step for 4 note chords inverted

      Functions in diamond_music_utils
            def build_all_ratios(): returns the all_ratios table for the 31-limit diamond
            def build_ratio_strings(): part of build_all_ratios
            def build_chords(mode, ratio, rank, inversion): # returns a 4 note chord
            def build_scales(mode, ratio, rank): # returns an 8 note scale
            def build_scale_mask(scale); # pass an 8 note scale and this function returns a mask to boost the octave for each note
            def ratio_string_to_float(ratio): # returns a floating point value from a ratio in string form: "16/9"
            def ratio_to_cents(ratio): # convert floating point ratio to cents
            def cents_to_ratio(cents): # convert cents to a ratio string
            def show_keys(): # returns the dictionary
            def show_scales(): # returns the dictionary
            def show_inversions(): # returns the dictionary
            def ratio_distance(start, end): # passed two ratios in string form returns a floating point ratio distance
            def make_ftable_glissando(t_num, gliss_type, ratio): # passed a table number, gliss, ratio. returns the array for scoreEvent. This is called by build_slides only. I should probably make it an underscore function. Later.
            def build_slides(start_table, chord_1, chord_2, gliss_type = 'slide'): # assembles an ftable with a slide starting at start_table and going as many notes as there are in chord_1. returns the the table numbers of the built slides
            def show_scale_ratios(scale): # pass a scale or chord and and return the ratios in the scale as an array of strings
            def start_logger(fname = LOGNAME): # start the logger 
            def flushMessages(cs, delay=0): # after shutting down csound, send the queued messages to the log
            def printMessages(cs, delay=0): # calls flushMessages 
            def load_csd(csd_file, strip_f0 = False): # reads in the csd text and returns a string which can be passed to csound
            def load_csound(csd_content): # reads in the long string of csd, returns cs ctcsound instance and pt perform thread
            def build_scale_mask(scale): # builds an octave mask that ensures a scale always goes up 
            def retrieve_gliss_tables(): # returns the  stored_gliss and current_gliss_table as two separate values
            def init_stored_gliss(): # reset the glissando table to zero 
            def update_gliss_table(gliss_table, current_gl): Updates the values in these tables and integer next available table number 
            
      Functions in the notebook that take a note_dict and generate a (notes, features) array of indeterminant length
            instrument(tone, octave, duration, hold, gliss, voice_name, velocity, stereo, env, upsample, renv, gliss2, gliss3, volume):
                  Takes the listed values and returns an array ready to be sent to csound. this returns (notes, features). There's no going back to notes.

            chord_play - just what it says, plays one tetrad 
                  if there are more instruments than notes it duplicates the 1st note at the end of the array.
                  octv: takes an array of octaves and assigns them randomly to the instruments
                  dur, hold, env: an array of dur & hold one per note = 4
                  repeats & loops: repeats each chord once. But if you have lots of dictionary lines it only does it once.
                  if dur = 0: Plays all the notes at once, no matter how many loops, or repeats
                  if repeat = 1: spreads the notes across the instruments

            scale_arpeggio - returns a list of 9 notes, a scale plus the start note on top (or bottom)
                  returns one note per instrument. 
                  repeats are allowed. repeat, notes, instruments in that order 
                  rolls are implemented over repeats
                  flips are allowed - done once 
                  dur, hold are an array, one for each note, 4 required np.array([.4,.2,.4,.2])
                  octave is an integer 
                  
            tetrad_arpeggio - returns an arpeggiated tetrad

            root_chord_slide - Takes two chords and will make a slide, or trill as requested. Takes repeats.
                  Used only in the A & B ranks 
                  needs a combo array to indicate what slides work best best_rank_inversion_combos

            chord_slide - Same as root_chord_slide, except it takes any two chords, all ranks allowed. octv says repeat.

            multiple_chord_slide - calls build_voice_slide. Builds an array of 9 notes by 4 voices based on the bridge_chords dictionary.             
                  Passed note_dict, needs to have the following keys:
                  octv, instruments, dur, hold, env, renv, defaults
            
            note_array - takes an array of (voices, notes) and returns an array that is ready for csound. No repeats. one octv
                  This is used to take the results of the grid search for the optimum path through the bridge in balloon drum music and creates and array that can go to csound.
                  note_dict keys: "note_array", "instruments", "octv", "dur, "hold", "env", "renv"
                  number of octv indicates number of repeats, but only sequentially. See the problem?
                  Could I double them up before I get there? Maybe.

            build_voice_slide - takes a voice and a table number.
                  builds the gliss table to slide across all notes in the argument & updates the global stored_gliss and current_gliss_table. 

            find_good_inversion(chord_number) - pass it the chord number in bridge_chords and it returns a list of decent inversions. Uses the data in good_slides. 

            fix_start_times - pass it a note_array and it will turn durations into the correct start times. returns the array ready to go to csound 
            largest_evenly_divisible(array_zise, max_number) - passed an integer, it will return the largest number evenly divisible into it, starting at max_number and descending until it finds one. 
            init_voice_start_times - initializes all the instrument start times to zero. 

            set_bridge_chord_rank takes a rank ('A', 'B', etc) and updates the bridge chord dictionary with new rank values. not really used anywhere yet. 
            choose_best_rank_inversion_combos(): - returns a random combination of ranks A & B with the best inversions for each.
            choose_random_rank - returns a random valid rank from show_inversions
            choose_random_mode - returns a random valid mode from show_scales
            show_voice_time_short_name - pass it a time_tracker voice number and it returns the short name for that instrument, and the csound voice number
                  voice_time_start[short_name]["csound_voice"] to use in the output array
      
      Functions that manipulate winds after they emerge from the note generating functions:
            masked(note_array, density_function): takes the array and zeros out some hold times. density function has to have the same first dimension as the note_array

            extend(note_array, min_dur, max_dur, budget = 0.10, likelihood = 0.20): extends the duration of random notes in winds array by at least min_dur and at most max_dur. Turns a 1/16th note into a longer note. I should make this take an array of values across time instead of just two values. Later.

            def build_density_function(y, points): creates a smooth function from array y, across the number of specified points
                  If you pass it the length of an array of notes it will create a smooth function across all the notes in that array.
            
            reset_voice_time(new_start): If fixed_winds timing gets whack, you can reset it to a fixed time and start a new section.
                  new_start = np.min(([voice_time[voice]["start"] for voice in voice_time])) - finds the minimum value of voice_time

      key variables in the notebook:
            all_bridge_chord_arrays - derived from the grid search for the best path through the bridge. 
                  all_bridge_chord_arrays.shape = (4, 19, 4, 9) where the dimensions are rank, 19 different choices in that rank, 4 voices and 9 notes
            verse_array - built on the fly:
                  path = build_note_array(0) # recursive function that calls itself if it can't find a path with more than 10 steps. hand_selected is 14. 
                  verse_array = np.array([dmu.build_chords("oton", "16/9", rank, inversion) for (rank, _, inversion, _, cents) in  path])
            winds - current repository for an array (notes, features) that can be manipulated to stretch, transform, and otherwize make more interesting a set of notes that are returned from the note generating functions
            fixed_winds - current repository of notes that have had their duration transformed into start times and can't really be altered without causing unintended consequences. Can be safely sent through masked(). 
            best_results - list of chord changes for two ranks taken together that minimize the cent distance for the verse section: (4, 16, 5) where the dimensions are rank set ('A', 'B') is 0, {'B', 'C'} is 1, etc, the best 16 collections of two chords, each collection has rank1, rank2, inv1, inv2, sum_of_cents_difference for those two chords. 
                  You can find the best path through those two chords by calling build_chord_array(rank_set) where rank_set is in the range of (0,3). It returns a path consisting of rank1, rank2, inv1, inv2, sum of cents, which can in return generate a note_array thusly:
                        path = build_note_array(0) # where the rank set is in the range of (0,3)
                        tones = np.array([dmu.build_chords("oton", "16/9", rank, inversion) for (rank, _, inversion, _, cents) in path])
                        print(f'{path = }\n{tones = }')

      Dictionaries in the notebook
            voice_time['fpn']['full'] = 'finger piano'
            voice_time['fpn']['start'] = 0
            voice_time['fpn']['number'] = 1
            bridge_chords[bridge_chord_num][start_or_end_chord]['mode']['ratio]['rank']['inversion']
            bridge_chords = {0: {0: {'mode': 'oton', 'ratio': '16/9', 'rank': 'A'}, # was 0
                     1: {'mode': 'oton', 'ratio': '8/7', 'rank': 'A'}},
                  It's a dictionary of mode, ratio, rank for the bridge chords. 
                  It starts out all rank = 'A', but you can change that with set_bridge_chord_rank function, passing in the bridge_chord, and rank you prefer. But I always explicitly set the rank when creating scales and tetrads
           
            Remember that scales are 8 notes, keys or modes are 16 notes, tetrads are four notes. 
                  Here is how you get a scale from a mode and a root:
            
            keys refers to a note number in the 256 note array from 0 to 255
            keys = {'oton': {'1/1': array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]),

            scales refers to the note number in the keys dictionary with numbers from 0 to 15
            scales =  'H': {'oton': array([12, 14,  0,  2,  5,  7,  9, 11]),
                              'uton': array([ 5,  3,  1, 15, 12, 10,  8,  6])}}

            inversions refer to the note number in the keys dictionary with numbers from 0 to 15                  
            inversions = {'A': {'oton': {1: array([ 0,  4,  8, 12]),
                  2: array([ 4,  8, 12,  0]),
                  3: array([ 8, 12,  0,  4]),
                  4: array([12,  0,  4,  8])},
            'uton': {1: array([12,  8,  4,  0]),
                  2: array([ 0, 12,  8,  4]),
                  3: array([ 4,  0, 12,  8]),
                  4: array([ 8,  4,  0, 12])}},        

            tetrads are built in dmu.build_chords(mode, root, rank, inversion) which returns 4 notes 
            scales are built in dmu.build_scales(mode, root, rank) which returns 8 notes 

Valid gliss types support by diamond_music_utils.py
      if gliss_type == 'slide':
            fn_array = np.array([t_num, 0, 256, -7, 1, 64, 1, 64, ratio, 128, ratio])
      elif gliss_type == 'cubic16_16_224':
            fn_array = np.array([t_num, 0, 256, -6, 1, 16, np.average((1, ratio)), 16, ratio, 224, ratio])
      elif gliss_type == 'cubic32_32_192':
            fn_array = np.array([t_num, 0, 256, -6, 1, 32, np.average((1, ratio)), 32, ratio, 192, ratio])
      elif gliss_type == 'cubic64_64_128':
            fn_array = np.array([t_num, 0, 256, -6, 1, 64, np.average((1, ratio)), 64, ratio, 128, ratio])
      elif gliss_type == 'cubic96_96_64':
            fn_array = np.array([t_num, 0, 256, -6, 1, 96, np.average((1, ratio)), 96, ratio, 64, ratio])
      elif gliss_type == 'cubic112_112_32':
            fn_array = np.array([t_num, 0, 256, -6, 1, 112, np.average((1, ratio)), 112, ratio, 32, ratio])
      elif gliss_type == 'trill_1_step':
            fn_array = np.array([t_num, 0, 32, -7, 1, 16, 1, 0, ratio, 16, ratio])
      elif gliss_type == 'trill_2_step':
            fn_array = np.array([t_num, 0, 64, -7, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio])
      elif gliss_type == 'trill_3_step':
            fn_array = np.array([t_num, 0, 64, -7, 1, 13, 1, 0, ratio, 13, ratio, 0, 1, 13, 1, 0, ratio, 13, ratio, 0, 1, 12, 1])
      elif gliss_type == 'trill_4_step':
            fn_array = np.array([t_num, 0, 128, -7, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio])
      elif gliss_type == 'trill_6_step':
            fn_array = np.array([t_num, 0, 256, -7, 1, 21, 1, 0, ratio, 21, ratio, 0, 1, 22, 1, 0, ratio, 21, ratio, 0, 1, 21, 1, 0, ratio, 22, ratio, 0, 1, 21, 1, 0, ratio, 21, ratio, 0, 1, 22, 1, 0, ratio, 21, ratio, 0, 1, 21, 1, 0, ratio, 22, ratio]) 
      elif gliss_type == 'trill_8_step':
            fn_array = np.array([t_num, 0, 256, -7, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio, 0, 1, 16, 1, 0, ratio, 16, ratio])
           
Valid voice_time values:
      voice_time = {
    "fp1": {"full_name": "finger piano 1", "start": 0, "csound_voice": 1, "time_tracker_number": 0},
    "fp2": {"full_name": "finger piano 2", "start": 0, "csound_voice": 1, "time_tracker_number": 1},
    "fp3": {"full_name": "finger piano 3", "start": 0, "csound_voice": 1, "time_tracker_number": 2},
    "fp4": {"full_name": "finger piano 4", "start": 0, "csound_voice": 1, "time_tracker_number": 3},
    "fp5": {"full_name": "finger piano 5", "start": 0, "csound_voice": 1, "time_tracker_number": 4},
    "fp6": {"full_name": "finger piano 6", "start": 0, "csound_voice": 1, "time_tracker_number": 5},
    "bn1": {"full_name": "bass finger piano 1", "start": 0, "csound_voice": 2, "time_tracker_number": 6},
    "bn2": {"full_name": "bass finger piano 2", "start": 0, "csound_voice": 2, "time_tracker_number": 7},
    "bd1": {"full_name": "bass balloon drum 1", "start": 0, "csound_voice": 3, "time_tracker_number": 8},
    "bd2": {"full_name": "bass balloon drum 2", "start": 0, "csound_voice": 3, "time_tracker_number": 9},
    "bd3": {"full_name": "bass balloon drum 3", "start": 0, "csound_voice": 3, "time_tracker_number": 10},
    "bd4": {"full_name": "bass balloon drum 4", "start": 0, "csound_voice": 3, "time_tracker_number": 11},
    "bm1": {"full_name": "medium balloon drum 1", "start": 0, "csound_voice": 4, "time_tracker_number": 12},
    "bm2": {"full_name": "medium balloon drum 2", "start": 0, "csound_voice": 4, "time_tracker_number": 13},
    "bm3": {"full_name": "medium balloon drum 3", "start": 0, "csound_voice": 4, "time_tracker_number": 14},
    "bm4": {"full_name": "medium balloon drum 4", "start": 0, "csound_voice": 4, "time_tracker_number": 15},
    "bh1": {"full_name": "high balloon drum 1", "start": 0, "csound_voice": 5, "time_tracker_number": 16},
    "bh2": {"full_name": "high balloon drum 2", "start": 0, "csound_voice": 5, "time_tracker_number": 17},
    "bh3": {"full_name": "high balloon drum 3", "start": 0, "csound_voice": 5, "time_tracker_number": 18},
    "bh4": {"full_name": "high balloon drum 4", "start": 0, "csound_voice": 5, "time_tracker_number": 19},
    "bf1": {"full_name": "bass flute 1", "start": 0, "csound_voice": 6, "time_tracker_number": 20},
    "bf2": {"full_name": "bass flute 2", "start": 0, "csound_voice": 6, "time_tracker_number": 21},
    "bf3": {"full_name": "bass flute 3", "start": 0, "csound_voice": 6, "time_tracker_number": 22},
    "bf4": {"full_name": "bass flute 4", "start": 0, "csound_voice": 6, "time_tracker_number": 23},
    "obo": {"full_name": "oboe", "start": 0, "csound_voice": 7, "time_tracker_number": 24},
    "cla": {"full_name": "clarinet", "start": 0, "csound_voice": 8, "time_tracker_number": 25},
    "bss": {"full_name": "bassoon", "start": 0, "csound_voice": 9, "time_tracker_number": 26},
    "frn": {"full_name": "french horn", "start": 0, "csound_voice": 10, "time_tracker_number": 27},
    "btg": {"full_name": "baritone guitar", "start": 0, "csound_voice": 11, "time_tracker_number": 28},
}
best rank inversions from A to B:
      print(*[(inx, str(combo)) for (inx, combo) in enumerate(best_rank_inversion_combos) if combo[0] != combo[1]], sep='\n')
            (8, "['A' 'B' '1' '1']")
            (9, "['A' 'B' '1' '4']")
            (10, "['A' 'B' '2' '1']")
            (11, "['A' 'B' '2' '2']")
            (12, "['A' 'B' '3' '2']")
            (13, "['A' 'B' '3' '3']")
            (14, "['A' 'B' '4' '3']")
            (15, "['A' 'B' '4' '4']")
            (16, "['B' 'A' '1' '1']")
            (17, "['B' 'A' '1' '2']")
            (18, "['B' 'A' '2' '2']")
            (19, "['B' 'A' '2' '3']")
            (20, "['B' 'A' '3' '3']")
            (21, "['B' 'A' '3' '4']")
            (22, "['B' 'A' '4' '1']")
            (23, "['B' 'A' '4' '4']")